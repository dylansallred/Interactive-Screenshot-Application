<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Screenshot Application</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <style>
:root {
    --local-box-color: #4CAF50;    /* default local color */
    --linked-box-color: #3498db;     /* color for linked boxes */
    --global-box-color: #9b59b6;     /* color for global boxes */
    --textbox-color: #be2d4c;
    --textbox-color-focus: #ffea00;
    --link-cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="%231E88E5" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>') 12 12, pointer;
}

/* --- UTILITY CLASSES --- */
.hidden { display: none !important; }
.link-mode-cursor, .link-mode-cursor * { cursor: var(--link-cursor) !important; }
.btn { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; }
.btn-positive { background-color: #4CAF50; color: white; }
.btn-positive:hover { background-color: #45a049; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }
.btn-negative { background-color: #f44336; color: white; }
.btn-negative:hover { background-color: #d32f2f; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

/* --- GLOBAL STYLES --- */
body, html {
    margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; background-color: #1e1e1e;
    color: #e0e0e0; touch-action: none; user-select: none; overflow: hidden;
}

#app { display: flex; height: 100%; position: relative; }

/* --- SIDE TOOLBAR --- */
#sideToolbarWrapper {
    position: fixed; left: 0; top: 0; bottom: 0; z-index: 1000; overflow: hidden;
    transition: transform 0.3s ease-out; transform: translateX(0);
}
#sideToolbarWrapper.hidden { transform: translateX(-280px); }
#sideToolbarWrapper.hidden ~ #sideToolbarToggle { left: 0; }
#sideToolbarWrapper.hidden ~ #sideToolbarToggle i { transform: rotate(180deg); }
#sideToolbarWrapper.hidden ~ #imageContainer { margin-left: 20px; }

#sideToolbar { width: 280px; background-color: #232323; border-right: 1px solid #444; display: flex; flex-direction: column; height: 100%; }
#sideToolbarToggle {
    width: 20px; background-color: #1e1e1e; display: flex; justify-content: center; align-items: center;
    cursor: pointer; position: fixed; top: 50%; transform: translateY(-50%); height: 60px;
    border-radius: 0 5px 5px 0; z-index: 999; box-shadow: 0px 0px 2px #ffffffab;
}
#sideToolbarToggle:hover { background-color: #89ff0005; box-shadow: inset -1px 0px 3px #77f22f99; transform: scaleX(1.1) translateY(-50%); }
#sideToolbarToggle i { transition: transform 0.15s; }

#sideToolbarHeader { padding: 15px; background-color: #2b2b2b; border-bottom: 1px solid #444; position: sticky; top: 0; z-index: 10; }
#sideToolbarHeader h3 { margin: 0 0 10px 0; text-align: center; }

/* Add this after #sideToolbarHeader h3 styles */
.box-counts {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 10px;
    font-size: 0.9em;
}

.count-item {
    display: flex;
    align-items: center;
    gap: 5px;
    opacity: 0.8;
    transition: opacity 0.2s;
}

.count-item:hover {
    opacity: 1;
}

.local-count i {
    color: var(--local-box-color);
}

.linked-count i {
    color: var(--linked-box-color);
}

.global-count i {
    color: var(--global-box-color);
}

.text-count i {
    color: var(--textbox-color);
}

.toolbar-controls { display: flex; justify-content: center; align-items: center; }
.toolbar-buttons { display: flex; }
.toolbar-slider { display: flex; align-items: center; gap: 10px; }
.toolbar-slider i { font-size: 14px; }

/* --- IMAGE CONTAINER --- */
#imageContainer {
    position: absolute; left: 2px; right: 0; top: 0; bottom: 0; display: flex;
    justify-content: center; align-items: center; background-color: #1e1e1e; z-index: 1;
}
#imageContainer img { max-width: 100%; height: auto; display: block; user-select: none; -webkit-user-drag: none; }

/* --- IMAGE LIST --- */
#imageList {
    flex-grow: 1; overflow-y: auto; padding: 5px; display: flex; flex-wrap: wrap;
    justify-content: center; align-content: flex-start; gap: 5px; margin: 0 auto;
}

.image-item {
    position: relative; cursor: pointer; border-radius: 4px; background-color: #333;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3); overflow: hidden; flex: 0 0 auto; margin: 0; padding: 0;
}
.image-item:not(.active):hover {
    box-shadow: 0 0 0px 2px #ffffff96, 0px 0px 13px 3px #ffffff9c; transform: scale(.95);
    border-radius: 15px; transition: all 0.3s ease-in-out; background-color: #444; z-index: 1;
}
.image-item:not(.active):hover .image-name { background-color: rgba(0, 0, 0, 0.8); color: #fff; }
.image-item:not(.active):hover::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0)); z-index: 2;
}
.image-item.active { box-shadow: 0 0 0px 2px #ff0000, 0px 0px 13px 3px #ff0000; }
.image-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
.image-item .image-name {
    position: absolute; bottom: 0; left: 0; right: 0; background-color: rgba(0, 0, 0, 0.6);
    color: white; font-size: 12px; padding: 2px 4px; text-align: center;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.image-item .image-actions { position: absolute; top: 0px; right: 1px; opacity: 0; transition: opacity 0.3s ease; z-index: 10; }
.image-item .image-actions button { pointer-events: auto; opacity: 1; } /* Ensure actions are visible */
.image-item:hover .image-actions { opacity: 1; }
#imageList.linking .image-item .image-actions { opacity: 0 !important; pointer-events: none; } /* Hide in linking mode */

.image-actions button {
    background: rgba(255, 255, 255, 0.8); border: none; border-radius: 50%; cursor: pointer;
    font-size: 10px; margin-left: 2px; padding: 0; display: flex; justify-content: center; align-items: center;
    box-shadow: 0px 0px 10px #00000096; margin-top: 1px; margin-bottom: 2px;
    transition: width 0.3s ease, height 0.3s ease, font-size 0.3s ease;
}
.rename-btn:hover { color: #4CAF50; }
.tag-btn:hover { color: #dd9624; }
.delete-btn:hover { color: #f44336; }
.delete-btn { margin-top: 2px; }

/* --- TOOLBAR ICON & TOOLBAR --- */
#toolbarIcon {
    position: fixed; bottom: 20px; right: 70px; width: 40px; height: 40px;
    background-color: rgba(60, 60, 60, 0.3); border-radius: 50%; display: flex;
    justify-content: center; align-items: center; cursor: pointer;
    transition: opacity 0.3s, background-color 0.3s, transform 0.3s; opacity: 1; z-index: 1000;
}
#toolbarIcon:hover { opacity: 1; background-color: rgb(39 85 104 / 90%); transform: scale(1.1); box-shadow: 0px 0px 20px #ffffff26; }
#toolbarIcon i { font-size: 20px; color: #e0e0e0; }

#toolbar {
    position: fixed; bottom: 70px; right: 20px; background-color: #333; padding: 10px;
    border-radius: 5px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); z-index: 1000;
}
#toolbar button { background: none; border: none; cursor: pointer; padding: 5px; font-size: 18px; color: #e0e0e0; }
#toolbar button.active { background-color: #4CAF50; color: white; }
#toolbar button:hover { background-color: #555; border-radius: 20%; transform: scale(1.2); }

/* --- BOXES --- */
.box {
    box-sizing: border-box; 
    position: absolute; 
    border: 2px solid var(--local-box-color);
    pointer-events: all; 
    box-shadow: inset 0 0 11px var(--local-box-color), 0 0 11px var(--local-box-color);
    border-radius: .2rem;
    transition: background-color 0.2s ease; /* Add transition for smooth effect */
}

/* Add hover effects for different box types */
.box:hover {
    background-color: color-mix(in srgb, var(--local-box-color) 50%, transparent); /* Local box hover color */
}

.box.linked:hover {
    background-color: color-mix(in srgb, var(--linked-box-color) 50%, transparent); /* Linked box hover color */
}

.box.global:hover {
    background-color: color-mix(in srgb, var(--global-box-color) 50%, transparent); /* Global box hover color */
}


.temp-box { border: 2px dashed var(--local-box-color); }
.box.linked { border-color: var(--linked-box-color); box-shadow: inset 0 0 11px var(--linked-box-color), 0 0 11px var(--linked-box-color); }
.box.global { border-color: var(--global-box-color); box-shadow: inset 0 0 11px var(--global-box-color), 0 0 11px var(--global-box-color); }
.box.moving { cursor: move!important; }
.box.linked, .box.global { transition: background-color 0.3s ease, border-color 0.3s ease; }
.box.global.hidden { opacity: 0.2; pointer-events: auto; cursor: not-allowed; }
.box.resizing { cursor: se-resize; }

.box-indicators {
    position: absolute; top: 0; left: 0; transform: translate(0, -100%); display: flex;
    flex-direction: row; gap: 2px; pointer-events: none; z-index: 10;
}
.box-indicators.show-indicators { display: flex; }
.box-indicators.hide-indicators { display: none; }

.indicator {
    background-color: rgba(0, 0, 0, 0.7); color: white; padding: 2px 4px; border-radius: 3px;
    display: flex; align-items: center; white-space: nowrap; margin-left: -2px;
}
.indicator i { margin-right: 4px; font-size: 0.9em; }
.global-indicator { background-color: rgba(155, 89, 182, 0.7); }
.linked-indicator { background-color: rgba(52, 152, 219, 0.7); }
.coord-info { pointer-events: none; z-index: 10; }


/* --- CONTEXT MENU --- */
#contextMenu {
    position: absolute; background-color: #333; border: 1px solid #555;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); z-index: 1000; border-radius: 5px;
    overflow: hidden; padding: 3px;
}
#contextMenu ul { list-style-type: none; padding: 0px; margin: 0; display: flex; flex-direction: row; }
#contextMenu.vertical ul { flex-direction: column; } /* Vertical layout */
#contextMenu li { padding: 8px; cursor: pointer; transition: all 0.3s ease; color: #e0e0e0; border-radius: 3px; }
#contextMenu li i {
    font-size: 16px; display: flex; justify-content: center; align-items: center;
    width: 100%; transition: color 0.3s ease, text-shadow 0.3s ease, transform 0.3s ease;
}
#contextMenu #replaceImage { font-size: .6rem; }
#contextMenu #replaceImage:hover { box-shadow: inset 0 0 20px 2px #000, 0 0 0px 0.25px #FFF; }

/* Individual context menu item hover effects */
#moveBox:hover { box-shadow: inset 0px 0px 10px 0px #45a049, 0px 0px 0px 1px #45a049; }
#moveBox:hover i { color: #45a049; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#copyBox:hover { box-shadow: inset 0px 0px 10px 0px #FFA500, 0px 0px 0px 1px #FFA500; }
#copyBox:hover i { color: #FFA500; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#resizeBox:hover { box-shadow: inset 0px 0px 10px 0px #FF1493, 0px 0px 0px 1px #FF1493; }
#resizeBox:hover i { color: #FF1493; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#linkBox:hover { box-shadow: inset 0px 0px 10px 0px #1c8efb, 0px 0px 0px 1px #1E90FF; }
#linkBox:hover i { color: #1E90FF; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#unlinkBox:hover { box-shadow: inset 0px 0px 10px 0px #FF4500, 0px 0px 0px 1px #FF4500; }
#unlinkBox:hover i { color: #FF4500; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#deleteBox:hover { box-shadow: inset 0px 0px 10px 0px #ca2212, 0px 0px 0px 1px #ca2212; }
#deleteBox:hover i { color: #ca2212; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#toggleGlobalBox:hover { box-shadow: inset 0px 0px 10px 0px #8e44ad, 0px 0px 0px 1px #8e44ad; }
#toggleGlobalBox:hover i { color: #8e44ad; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#editVisibility:hover { box-shadow: inset 0px 0px 10px 0px #4CAF50, 0px 0px 0px 1px #4CAF50; }
#editVisibility:hover i { color: #4CAF50; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }
#hideUnhideGlobal:hover { box-shadow: inset 0px 0px 10px 0px #c0392b, 0px 0px 0px 1px #c0392b; }
#hideUnhideGlobal:hover i { color: #c0392b; text-shadow: 0 0 15px rgba(0, 0, 0, 1); transform: translateY(-1px); }

.global-options-container {
    display: flex; border-radius: 5px; margin-left: 2px; margin-top: 0px;
    border-left: .25px solid #FFF; border-right: .25px solid #FFF;
}
#contextMenu.vertical .global-options-container {  flex-direction: column; margin-top: 3px; margin-left: 0px;} /* Vertical Layout */

.global-options-container li.active { box-shadow: inset 0px 0px 15px 0px #be4fef; }
#contextMenu li.global-option { font-size: 0.9em; }

/* --- UPLOAD BUTTON --- */
.upload-btn {
    display: flex; justify-content: center; align-items: center; background-color: #4CAF50;
    color: white; border-radius: 10%; cursor: pointer; margin-left: 10px;
    border: 2px solid #3c7f3e; padding: 10px; transition: transform 0.3s ease;
}
.upload-btn:hover { background-color: #45a049; transform: scale(1.1); box-shadow: inset 0px 0px 3px 0px #f1f1f1; }
#uploadScreenshot { display: none; }

/* --- LINKING STYLES --- */
#imageList.linking .image-item { cursor: pointer; opacity: 0.7; transition: opacity 0.3s ease; }
#imageList.linking .image-item:hover { opacity: 1; }

.link-message {
    text-align: center; padding: 10px; background-color: #f0f0f0; margin-bottom: 10px;
    font-weight: bold; color: #4CAF50; border: 2px solid #4CAF50; border-radius: 5px;
}
.link-message-overlay {
    position: absolute; top: 215px; left: 0; right: 0; bottom: 0; background-color: rgba(55, 100, 0, 0.10);
    color: #ffffff; display: flex; justify-content: center; align-items: flex-start; padding-top: 15vh;
    text-align: center; z-index: 1000; transition: opacity 0.3s ease; pointer-events: none;
    font-size: 25px; text-shadow: -3px 2px 2px rgba(0, 0, 0, 0.7); box-shadow: inset 0px 0px 13px 3px #4caf502e;
}
.link-message-overlay i { padding: 0px 10px; }

/* --- CONTEXT SUBMENU --- */
.context-submenu {
    position: absolute; background-color: #333; border: 1px solid #555;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); z-index: 1001; border-radius: 5px;
    padding: 10px; max-height: 300px; overflow-y: auto;
}
.context-submenu h3 { margin-top: 0; margin-bottom: 10px; }
.context-submenu ul { list-style-type: none; padding: 0; margin: 0; }
.context-submenu li { margin-bottom: 5px; }
.context-submenu button {
    margin-top: 10px; padding: 5px 10px; background-color: #4CAF50;
    color: white; border: none; border-radius: 3px; cursor: pointer;
}
.context-submenu button:hover { background-color: #45a049; }

/* --- MODALS --- */
.modal-overlay, .tag-manager-modal {
    background-color: rgba(0, 0, 0, 0.85); position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; display: flex; justify-content: center;
    align-items: center; z-index: 1000; backdrop-filter: blur(5px);
}
.modal { /* Added for consistency with .modal-overlay */
        background-color: rgba(0, 0, 0, 0.4);
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(5px);
}

.visibility-modal, .modal-content, .tag-manager-content {
    overflow-y: auto; background-color: #1e1e1e; padding: 40px; border-radius: 16px; 
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4); color: #f0f0f0; max-height: 80vh;
    display: flex; flex-direction: column;
}

.visibility-modal{
    min-width: 600px;
}

.modal-content {
    max-width: 750px; min-width: 200px;
}

.tag-manager-content{
    max-width: 500px;
}

.visibility-header { flex-shrink: 0; }
.visibility-modal h3, .modal h2, .tag-manager-content h2  { margin-top: 0; margin-bottom: 10px; text-align: center; color: #4CAF50; }
.visibility-modal p { margin-bottom: 15px; text-align: center; }

.visibility-controls { display: flex; justify-content: space-between; margin-bottom: 15px; gap: 13px; }
.visibility-controls button {
    background-color: #3a3a3a; color: #e0e0e0; border: none; padding: 7px 15px;
    border-radius: 4px; cursor: pointer; transition: background-color 0.3s; width: 20%;
}
.visibility-controls button:hover { background-color: #4CAF50; }

.checkbox-list-container { position: relative; overflow-y: auto; max-height: 60vh; padding: 10px; }
.checkbox-list { position: relative; }
.virtual-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; width: 100%; }

.checkbox-item {
    animation: fadeIn 0.3s ease-in; background: #2a2a2a; border-radius: 8px; padding: 5px;
    display: flex; align-items: center; gap: 8px;
}
.checkbox-item:has(input:checked) { border: 2px solid #4CAF50; box-shadow: 0 0 10px rgba(76, 175, 80, 0.5); }
.checkbox-item:hover { background-color: #4a4a4a; }
.checkbox-item input[type="checkbox"] { margin-right: 10px; }
.checkbox-item label { display: flex; align-items: center; cursor: pointer; width: 100%; overflow: hidden; }
.checkbox-item img { width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 10px; flex-shrink: 0; }
.checkbox-item span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: calc(100% - 50px); }

.visibility-actions { display: flex; justify-content: flex-end; gap: 10px; flex-shrink: 0; }
.visibility-actions button { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }

/* --- DELETE ALL BUTTON --- */
.delete-all-btn {
    display: flex; justify-content: center; align-items: center; background-color: #f44336;
    color: white; border-radius: 10%; cursor: pointer; margin-left: 10px;
    border: 2px solid #a32c23; padding: 10px; width: 40px; transition: transform 0.3s ease;
}
.delete-all-btn:hover { background-color: #d32f2f; transform: scale(1.1); box-shadow: inset 0px 0px 3px 0px #f1f1f1; }

/* --- SLIDERS --- */
input[type="range"] { background-color: #444; }
input[type="range"]::-webkit-slider-thumb,
input[type="range"]::-moz-range-thumb,
input[type="range"]::-ms-thumb { background: #4CAF50; }

#imageSizeSlider {
    -webkit-appearance: none; width: 100%; height: 4px; border-radius: 2px;
    background: #444; outline: none; margin: 10px 0; position: relative;
}
#imageSizeSlider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%;
    background: #4CAF50; cursor: pointer; transition: all 0.2s ease; position: relative; z-index: 3;
}
#imageSizeSlider::-moz-range-thumb {
    width: 16px; height: 16px; border-radius: 50%; background: #4CAF50;
    cursor: pointer; transition: all 0.2s ease; border: none; position: relative; z-index: 3;
}
#imageSizeSlider::-webkit-slider-thumb:hover, #imageSizeSlider::-moz-range-thumb:hover {
    background: #45a049; transform: scale(1.2);
}

.slider-container { position: relative; width: 100%; padding: 15px 0; }
.slider-notches {
    position: absolute; top: 50%; left: 0; right: 0; height: 4px;
    display: flex; justify-content: space-between; pointer-events: none;
}
.notch { width: 2px; height: 8px; background-color: #666; transform: translateY(-50%); }
.notch-label { position: absolute; top: 15px; transform: translateX(-50%); font-size: 10px; color: #888; }

/* --- MODE INDICATOR --- */
#modeIndicator { pointer-events: none; z-index: 10000; }
.mode-indicator {
    position: fixed; bottom: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7);
    color: white; padding: 10px 15px; border-radius: 20px; font-size: 14px;
    display: flex; align-items: center; transition: opacity 0.3s ease; z-index: 1000;
}
.mode-indicator.hidden { opacity: 0; pointer-events: none; }
.mode-indicator i { margin-right: 8px; }

/* --- RESIZE HANDLE --- */
.resize-handle {
    position: absolute !important; right: -6px !important; bottom: -6px !important;
    width: 10px !important; height: 10px !important; cursor: se-resize !important;
    background-color: #ffffff !important; border-radius: 50% !important;
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.3) !important; transition: transform 0.2s ease !important;
}

/* --- SORTABLE --- */
.sortable-ghost { opacity: 0.2; }
.sortable-drag { opacity: 0.8; }
.sortable-chosen { box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); }
.sortable-placeholder { border: 2px dashed #4CAF50; background-color: rgba(76, 175, 80, 0.2); }

/* --- HELP ICON --- */
#helpIcon {
    position: fixed; bottom: 20px; right: 20px; width: 40px; height: 40px;
    background-color: rgba(60, 60, 60, 0.3); border-radius: 50%; display: flex;
    justify-content: center; align-items: center; cursor: pointer;
    transition: opacity 0.3s, background-color 0.3s, transform 0.3s; opacity: 1; z-index: 1000;
}
#helpIcon:hover { opacity: 1; background-color: rgb(90 47 72); transform: scale(1.1); box-shadow: 0px 0px 20px #ffffff26; }
#helpIcon i { font-size: 20px; color: #e0e0e0; }

/* --- SETTING ITEMS (in Modals) --- */
.setting-item { margin-bottom: 20px; }
.setting-item label { display: block; margin-bottom: 5px; }
.setting-item input[type="text"] {
    width: 100%; padding: 5px; border: 1px solid #444;
    background-color: #333; color: #e0e0e0;
}
.setting-item input[type="color"] {
    width: 100%; height: 40px; padding: 0; border: none;
    background-color: transparent;
    cursor: pointer;
}

/* --- ANIMATIONS --- */
@keyframes glowPulse {
    0%, 100% { box-shadow: 0 0 5px 2px rgba(76, 175, 80, 0.5); }
    50% { box-shadow: 0 0 20px 10px rgba(76, 175, 80, 0.5); }
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
@keyframes pulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
}
@keyframes progressBar {
    0% { width: 0%; }
    100% { width: 100%; }
}
@keyframes activeImageGlow {
    0%, 100% { box-shadow: 0 0 0px 1.5px #4CAF50, 0px 0px 20px 3px #45a049; }
    50% { box-shadow: 0 0 0px 1px #4caf507a, 0px 0px 5px 3px #45a04973; }
}
@keyframes linkHighlight {
    0% { transform: rotate(0deg) scale(1); }
    100% { transform: rotate(360deg) scale(1); }
}

/* --- GLOW INDICATOR --- */
.glow-indicator { animation: glowPulse 2s infinite; }
#sideToolbarToggle.glow-indicator { z-index: 1000; }
.upload-btn.glow-indicator { z-index: 1000; }

/* --- PLACEHOLDER CONTENT --- */
.placeholder-content i { padding: 4px; border-radius: 4px; }

/* --- IMAGE TAGS (within image items)--- */
.image-tags { font-size: 0.8em; color: #888; margin-top: 2px; }

/* --- SEARCH & FILTER --- */
.search-container { margin-bottom: 10px; margin-top: 10px; }
#imageSearch, #tagFilter {
    width: 100%; padding: 8px; border: 1px solid #444; background-color: #2d2d2d;
    color: #e0e0e0; border-radius: 4px; width: -webkit-fill-available;
}
#tagFilter {
    appearance: none; -webkit-appearance: none; -moz-appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg fill="%23e0e0e0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
    background-repeat: no-repeat; background-position: right 8px center; text-align: center;
}

/* --- TAG MANAGER --- */
#currentTags { margin-bottom: 20px; min-height: 40px; display: flex; flex-wrap: wrap; gap: 5px; }

.tag {
    display: inline-flex; align-items: center; background-color: #2a2a2a; color: #f0f0f0;
    padding: 5px 10px; border-radius: 25px; font-size: 14px; transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 0 4px 0px #81ff00;
}
.tag:hover { background-color: #333; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

.remove-tag {
    background: none; border: none; color: #f0f0f0; cursor: pointer; font-weight: bold;
    margin-left: 8px; font-size: 18px; transition: color 0.3s ease; padding: 0 4px;
}
.remove-tag:hover { color: #f44336; }

#newTag, #drawBoxShortcut, #drawTextShortcut {
    width: -webkit-fill-available; padding: 10px; border: 2px solid #333; background-color: #2a2a2a;
    color: #f0f0f0; border-radius: 8px; font-size: 16px; transition: all 0.3s ease;
}

#newTag:focus,  #drawBoxShortcut:focus,  #drawTextShortcut:focus {
    outline: none; border-color: #4CAF50; box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
}

#linkedBoxColor, #globalBoxColor {
     width: -webkit-fill-available;
     border: 2px solid #333;
     background-color: #2a2a2a;
     color: #f0f0f0;
     border-radius: 8px;
     font-size: 16px;
     transition: all 0.3s ease;
}
    
#linkedBoxColor:focus, #globalBoxColor:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
}

#recentTags { margin-top: 25px; margin-bottom: 25px; }
#recentTags h3 { font-size: 18px; margin-bottom: 15px; color: #888; font-weight: 300; }
#recentTagsList { display: flex; flex-wrap: wrap; gap: 8px; }

.recent-tag {
    background-color: #333; color: #f0f0f0; border: none; border-radius: 25px;
    padding: 8px 16px; cursor: pointer; font-size: 14px; transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
.recent-tag:hover { background-color: #444; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }

.center-buttons { display: flex; justify-content: center; gap: 10px; }

/* --- TEXTBOX --- */
.textbox {
    box-sizing: border-box;
    position: absolute;
    border: 2px solid var(--textbox-color);
    background-color: #192134;
    border-radius: .4rem;
    pointer-events: all;
    box-shadow: inset 0 0 11px var(--textbox-color), 0 0 11px var(--textbox-color);
    overflow: hidden; /* Add this to prevent content overflow */
}

.textbox-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform-origin: top left;
    display: flex;
    align-items: center;
    justify-content: center;
}

.textbox .textbox-content {
    width: 100%;
    height: 100%;
    color: #e0e0e0;
    padding: 10px;
    box-sizing: border-box;
    font-size: 14px;
    line-height: 1.2;
    outline: none;
    transition: all 0.3s ease;
    border-radius: .4rem;
    overflow-y: auto;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    user-select: text !important;
    -webkit-user-select: text !important;
    -moz-user-select: text !important;
    -ms-user-select: text !important;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

.textbox-content:focus {
    box-shadow: inset 0 0 1px 2px var(--textbox-color-focus);
    border-radius: 5px;
}

.textbox.temp-textbox {
    background-color: transparent;
    border: 2px dashed var(--textbox-color);
}

/* --- TEXTBOX SCROLLBAR (Webkit) --- */
.textbox .textbox-content::-webkit-scrollbar { width: 8px; }
.textbox .textbox-content::-webkit-scrollbar-track { background: #192134; }
.textbox .textbox-content::-webkit-scrollbar-thumb { background-color: #888; border-radius: 4px; border: 2px solid #192134; }

/* --- LOADING INDICATOR --- */

.loading-indicator {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    background-color: #2b2b2b !important;
    color: #e0e0e0 !important;
    padding: 20px !important;
    text-align: center !important;
    z-index: 2000 !important;
    border: none !important;
    font-size: 20px !important;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    animation: fadeIn 0.3s ease-in; /* Keep the fadeIn, it looks good on initial appearance */
}

/* Spinner */
.loading-indicator::before {
    content: '';
    width: 40px;
    height: 40px;
    border: 3px solid #4CAF50;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* Loading Text */
.loading-indicator span {
    font-size: 14px;
    animation: pulse 1.5s ease-in-out infinite;
}

/* Progress Bar */
.loading-indicator.progress {
    width: 100%;
    height: 4px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 10px;
}

.loading-indicator.progress::after {
    content: '';
    display: block;
    width: 0%;
    height: 100%;
    background-color: #4CAF50;
    animation: progressBar 2s ease-in-out;  /*  animation */
}
strong{
    border-radius: 5px;
    background-color: #293d4e;
    padding: 2px;
}

.flowchart-content {
    width: 90vw;
    height: 80vh;
    max-width: none !important;
    background-color: #1e1e1e;
}

#flowchartContainer {
    width: 100%;
    height: calc(100% - 50px);
    overflow: auto;
    position: relative;
    background-color: #2b2b2b;
    border-radius: 4px;
}

.flow-node {
    position: absolute;
    background: #2b2b2b;
    border: 2px solid var(--linked-box-color);
    border-radius: 8px;
    overflow: hidden;
    cursor: move;
    transition: transform 0.2s, box-shadow 0.2s;
}

.flow-node:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
    z-index: 2;
}

.flow-node img {
    width: 100%;
    height: 100px;
    object-fit: cover;
    border-bottom: 1px solid #444;
}

.flow-node .title {
    padding: 8px;
    font-size: 12px;
    color: #fff;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    background: rgba(0, 0, 0, 0.7);
}

#flowchartContainer {
    overflow: auto;
    background: #1e1e1e;
    position: relative;
    height: calc(100vh - 100px);
}

#flowchartContainer::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

#flowchartContainer::-webkit-scrollbar-thumb {
    background: #4CAF50;
    border-radius: 4px;
}

#flowchartContainer::-webkit-scrollbar-track {
    background: #2b2b2b;
}

.flow-connection {
    position: absolute;
    pointer-events: none;
    z-index: 1;
}

.flow-connection path {
    stroke: #4CAF50;
    stroke-width: 2;
    fill: none;
    filter: drop-shadow(0 0 3px rgba(76, 175, 80, 0.3));
}
</style>
</head>
<body>
    <div id="app">
        <div id="modeIndicator" class="mode-indicator hidden">
            <i class="fas"></i>
            <span></span>
        </div>
        <div id="sideToolbarWrapper" class="hidden">
            <div id="sideToolbar">
                <div id="sideToolbarHeader">
                    <h3>Screenshots</h3>
                    <!-- Add this new div for box counts after the h3 -->
                    <div class="box-counts">
                        <span class="count-item local-count" title="Local Boxes">
                            <i class="fas fa-square"></i> <span>0</span>
                        </span>
                        <span class="count-item linked-count" title="Linked Boxes">
                            <i class="fas fa-square"></i> <span>0</span>
                        </span>
                        <span class="count-item global-count" title="Global Boxes">
                            <i class="fas fa-square"></i> <span>0</span>
                        </span>
                        <span class="count-item text-count" title="Text Boxes">
                            <i class="fas fa-font"></i> <span>0</span>
                        </span>
                    </div>
                    <div class="toolbar-controls">
                        <div class="toolbar-buttons">
                            <label for="uploadScreenshot" class="toolbar-btn upload-btn" title="Upload Images">
                                <i class="fas fa-upload"></i>
                            </label>
                            <button id="deleteAllScreenshots" class="toolbar-btn delete-all-btn" title="Delete All Images">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                        <input type="file" id="uploadScreenshot" accept="image/*" multiple>
                    </div>
                    <div class="toolbar-slider" title="Adjust Thumbnail Image Size">
                        <i class="fas fa-images fa-sm"></i>
                        <!-- Replace the existing slider with this -->
                        <div class="slider-container">
                            <input type="range" id="imageSizeSlider" min="1" max="4" value="2" step="1">
                            <div class="slider-notches">
                                <div class="notch" style="left: 0%"><span class="notch-label">XS</span></div>
                                <div class="notch" style="left: 33.3%"><span class="notch-label">S</span></div>
                                <div class="notch" style="left: 66.6%"><span class="notch-label">M</span></div>
                                <div class="notch" style="left: 100%"><span class="notch-label">L</span></div>
                            </div>
                        </div>
                        <i class="fas fa-image fa-lg"></i>
                    </div>
                    <div class="search-container">
                        <input type="text" id="imageSearch" placeholder="Search images...">
                    </div>
                    <div class="tag-filter">
                        <select id="tagFilter">
                            <option value="">All Tags</option>
                            <!-- Dynamically add tags here -->
                        </select>
                    </div>
                </div>
                <div id="imageList"></div>
            </div>
        </div>
        <div id="sideToolbarToggle" style="left: 0px;"" title="Open/Close Sidebar">
            <i class="fas fa-chevron-left"></i>
        </div>
        <div id="imageContainer">
            <!-- Add this new div for the placeholder message -->
            <div id="placeholderMessage" class="placeholder-message">
                <div class="placeholder-content">
                    <i class="fas fa-image fa-10x"></i>
                    <h2>No Images Added</h2>
                    <p>Upload screenshots to get started</p>
                    <p>Click the <i class="fas fa-upload"></i> button in the sidebar</p>
                </div>
            </div>
        </div>
        <div id="toolbarIcon" title="Tools">
            <i class="fas fa-wrench"></i>
        </div>
        <div id="helpIcon" title="Help & Information">
            <i class="fas fa-question-circle"></i>
        </div>
        <div id="toolbar" class="hidden">
            <button id="drawBox"><i class="fas fa-draw-polygon" title="Draw Box"></i></button>
            <button id="saveProject"><i class="fas fa-save" title="Save Project"></i></button>
            <button id="openProject"><i class="fas fa-folder-open" title="Upload Project"></i></button>
            <button class="hidden" id="showFlowchart"><i class="fas fa-project-diagram" title="View Image Flow"></i></button>
            <button id="settingsBtn"><i class="fas fa-cog" title="Settings"></i></button>
        </div>
        <!-- Existing modals -->
        <div id="helpModal" class="modal hidden">
            <div class="modal-content" onclick="event.stopPropagation();">
                <h2>Help & Information</h2>
                <div id="helpContent"></div>
            </div>
        </div>
        <div id="settingsModal" class="modal hidden">
            <div class="modal-content" onclick="event.stopPropagation();">
                <h2>Settings</h2>
                <div class="setting-item">
                    <label for="drawBoxShortcut">Draw Box Shortcut:</label>
                    <input type="text" id="drawBoxShortcut" placeholder="Press keys..." style="width: auto;">
                </div>
                <div class="setting-item">
                    <label for="drawTextShortcut">Draw Text Shortcut:</label>
                    <input type="text" id="drawTextShortcut" placeholder="Press keys..." style="width: auto;">
                </div>
                <div class="setting-item">
                    <label for="localBoxColor">Local Box Color:</label>
                    <input type="color" id="localBoxColor" value="#4CAF50">
                </div>
                <div class="setting-item">
                    <label for="linkedBoxColor">Linked Box Color:</label>
                    <input type="color" id="linkedBoxColor" value="#3498db">
                </div>
                <div class="setting-item">
                    <label for="globalBoxColor">Global Box Color:</label>
                    <input type="color" id="globalBoxColor" value="#9b59b6">
                </div>
                <div class="setting-item">
                    <label for="textboxColor">Text Box Color:</label>
                    <input type="color" id="textboxColor" value="#be2d4c">
                </div>
            </div>
        </div>
        <!-- NEW: Save Project Modal -->
        <div id="saveProjectModal" class="modal hidden">
            <div class="modal-content" onclick="event.stopPropagation();">
                <h2>Save Project</h2>
                <div class="setting-item">
                    <label for="saveProjectFilename">File Name:</label>
                    <input type="text" id="saveProjectFilename" placeholder="Enter file name here" value="interactive_screenshot_app.html">
                </div>
                <div class="center-buttons">
                    <button id="saveProjectConfirm" class="btn btn-positive">Save</button>
                    <button id="saveProjectCancel" class="btn btn-negative">Cancel</button>
                </div>
            </div>
        </div>
        <!-- End new modal -->

        <!-- Add new flowchart modal -->
        <div id="flowchartModal" class="modal hidden">
            <div class="modal-content flowchart-content" onclick="event.stopPropagation();">
                <div id="flowchartContainer"></div>
            </div>
        </div>
    </div>
    <div id="contextMenu" class="hidden">
        <ul></ul>
    </div>
    <script>

            // Constants
// This object holds all the constant values and states used throughout the application
const constants = {
    currentScreenshot: null, // Currently displayed screenshot
    screenshots: [], // Array to store all uploaded screenshots
    boxes: [], // Array to store all drawn boxes
    globalBoxes: [], // Array to store boxes that appear on multiple screenshots
    isDrawing: false, // Flag to indicate if the user is currently drawing a box
    startX: null, // Starting X coordinate for box drawing
    startY: null, // Starting Y coordinate for box drawing
    scale: 1, // Scale factor for image display
    isMoving: false, // Flag to indicate if a box is being moved
    movingBox: null, // Reference to the box being moved
    currentScreenshotIndex: -1, // Index of the currently displayed screenshot
    lastMoveTime: 0, // Timestamp of the last box move action
    showUIElements: true, // Flag to control visibility of UI elements
    isResizing: false, // Flag to indicate if a box is being resized
    resizingBox: null, // Reference to the box being resized
    drawBoxShortcut: { key: 'B', shiftKey: false, ctrlKey: false, altKey: false }, // Keyboard shortcut for drawing boxes
    resizeTimeout: null, // Timeout for resize event handling
    linkedBoxColor: '#3498db', // Color for linked boxes
    globalBoxColor: '#9b59b6', // Color for global boxes
    textboxColor: '#be2d4c', // Color for textboxes
    localBoxColor: '#4CAF50', // Color for local boxes
    originalDrawBoxShortcut: null, // Stores the original draw box shortcut
    imageSizes: [65, 87, 135, 270], // Predefined image sizes for thumbnails
    lastClickTime: 0, // Timestamp of the last click event
    modeIndicator: null,
    // In the constants object, add these new properties:
    snapThreshold: 5, // Distance in pixels to trigger snapping
    snapStickiness: 15, // Distance in pixels required to unstick a snapped box
    // NEW properties for textboxes:
    drawTextShortcut: { key: 'T', shiftKey: false, ctrlKey: false, altKey: false },
    isDrawingText: false,  // flag for text drawing mode
    textStartX: null,
    textStartY: null,
    textBoxes: [],         // regular textboxes
    globalTextBoxes: [],    // global textboxes
    // Get existing APP_ID or generate new one
    APP_ID: localStorage.getItem('interactive-screenshot-app-id') || (() => {
        const newId = 'interactive-screenshot-app-' + Math.random().toString(36).substring(2, 15);
        localStorage.setItem('interactive-screenshot-app-id', newId);
        return newId;
    })(),
    // NEW: Add a resize throttle time
    resizeThrottleTime: 16,  // Throttle to ~60fps (1000ms / 60)
    lastResizeTime: 0, // NEW: Add a variable to track the last resize time
};

// DOM Elements
// This object stores references to frequently used DOM elements
const domElements = {
    imageContainer: document.getElementById('imageContainer'),
    toolbarIcon: document.getElementById('toolbarIcon'),
    toolbar: document.getElementById('toolbar'),
    uploadScreenshotInput: document.getElementById('uploadScreenshot'),
    drawBoxBtn: document.getElementById('drawBox'),
    saveProjectBtn: document.getElementById('saveProject'),
    openProjectBtn: document.getElementById('openProject'),
    imageList: document.getElementById('imageList'),
    contextMenu: document.getElementById('contextMenu'),
    sideToolbarWrapper: document.getElementById('sideToolbarWrapper'),
    sideToolbarToggle: document.getElementById('sideToolbarToggle'),
    deleteAllScreenshotsBtn: document.getElementById('deleteAllScreenshots'),
    imageSizeSlider: document.getElementById('imageSizeSlider'),
    helpIcon: document.getElementById('helpIcon'),
    helpModal: document.getElementById('helpModal'),
    closeHelp: document.getElementById('closeHelp'),
    helpContent: document.getElementById('helpContent'),
    settingsBtn: document.getElementById('settingsBtn'),
    settingsModal: document.getElementById('settingsModal'),
    drawBoxShortcutInput: document.getElementById('drawBoxShortcut'),
    saveSettingsBtn: document.getElementById('saveSettings'),
    closeSettingsBtn: document.getElementById('closeSettings'),
    sideToolbar: document.getElementById('sideToolbar'),
    modeIndicator: document.getElementById('modeIndicator'),
    flowchartModal: document.getElementById('flowchartModal'),
    flowchartContainer: document.getElementById('flowchartContainer'),
    showFlowchart: document.getElementById('showFlowchart')
};

// Utility Functions
// This object contains helper functions used throughout the application
const utils = {
    // Debounce function to limit the rate at which a function can fire
    debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    
    // NEW: Throttle function
    throttle: (func, limit) => {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    },
    
    // Calculate the scale factor for image display
    calculateScaleFactor: (imgWidth, imgHeight, containerWidth, containerHeight) => {
        const widthRatio = containerWidth / imgWidth;
        const heightRatio = containerHeight / imgHeight;
        return Math.min(widthRatio, heightRatio, 1);
    },
    
    // Mix two colors
    mixColors: (color1, color2) => {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);
        
        const r = Math.round((r1 + r2) / 2).toString(16).padStart(2, '0');
        const g = Math.round((g1 + g2) / 2).toString(16).padStart(2, '0');
        const b = Math.round((b1 + b2) / 2).toString(16).padStart(2, '0');
        
        return `#${r}${g}${b}`;
    },

    // Monitor click performance
    monitorClickPerformance: (e) => {
        const now = performance.now();
        const timeSinceLastClick = now - constants.lastClickTime;
        console.log(`Time since last click: ${timeSinceLastClick.toFixed(2)}ms`);
        constants.lastClickTime = now;
    },

    // Check for overlapping elements at click position
    checkOverlappingElements: (e) => {
        const elements = document.elementsFromPoint(e.clientX, e.clientY);
        console.log('Elements at click position:', elements);
    }
};

// Core Functions
// This object contains the main functionality of the application
const core = {
    // Update the list of images in the sidebar
    updateImageList: () => {
        console.log('Updating image list...');
        // Clear the existing image list
        domElements.imageList.innerHTML = '';
        // Iterate through all screenshots
        constants.screenshots.forEach((screenshot, index) => {
            // Create a new div for each screenshot
            const div = document.createElement('div');
            // Set the class name, marking the current screenshot as active
            div.className = `image-item ${index === constants.currentScreenshotIndex ? 'active' : ''}`;
            // Populate the div with screenshot details and action buttons
            div.innerHTML = `
                <img src="${screenshot.data}" alt="${screenshot.name}">
                <div class="image-name">${screenshot.name}</div>
                <div class="image-tags">${(screenshot.tags || []).join(', ')}</div>
                <div class="image-actions">
                    <button class="rename-btn" title="Rename"><i class="fas fa-edit"></i></button>
                    <button class="tag-btn" title="Manage Tags"><i class="fas fa-tags"></i></button>
                    <button class="delete-btn" title="Delete"><i class="fas fa-trash-alt"></i></button>
                </div>
            `;
            
            // Add event listener for mousedown on the div
            div.addEventListener('mousedown', (e) => {
                // Prevent event propagation if rename or delete buttons are clicked
                if (e.target.closest('.rename-btn, .delete-btn')) {
                    e.stopPropagation();
                    return;
                }

                // Record the starting position of the mouse
                const startX = e.clientX;
                const startY = e.clientY;

                // Define a handler for the mouseup event
                const mouseUpHandler = (upEvent) => {
                    // Calculate the distance the mouse has moved
                    const endX = upEvent.clientX;
                    const endY = upEvent.clientY;
                    const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));

                    // If the mouse hasn't moved much, consider it a click
                    if (distance < 5) {
                        console.log(`Clicked on screenshot: ${screenshot.name}`);
                        // Display the screenshot if we're not in linking mode
                        if (!domElements.imageList.classList.contains('linking')) {
                            core.displayScreenshot(index);
                        }
                    }

                    // Remove the mouseup event listener
                    document.removeEventListener('mouseup', mouseUpHandler);
                };

                // Add the mouseup event listener
                document.addEventListener('mouseup', mouseUpHandler);
            });
            
            // Add event listener for the rename button
            const renameBtn = div.querySelector('.rename-btn');
            renameBtn.addEventListener('click', (e) => {
                // Check if we're in linking mode - if so, ignore the click
                if (domElements.imageList.classList.contains('linking')) {
                    return;
                }
                e.stopPropagation();
                // Prompt for a new name and update if provided
                const newName = prompt('Enter new name:', screenshot.name);
                if (newName && newName !== screenshot.name) {
                    screenshot.name = newName;
                    core.updateImageList();
                }
            });
            
            // Add event listener for the delete button
            const deleteBtn = div.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', (e) => {
                // Check if we're in linking mode - if so, ignore the click
                if (domElements.imageList.classList.contains('linking')) {
                    return;
                }
                e.stopPropagation();
                // Confirm before deleting
                if (confirm('Are you sure you want to delete this image?')) {
                    core.deleteScreenshot(index);
                }
            });

            // Add event listener for the tag button
            const tagBtn = div.querySelector('.tag-btn');
            tagBtn.addEventListener('click', (e) => {
                // Check if we're in linking mode - if so, ignore the click
                if (domElements.imageList.classList.contains('linking')) {
                    return;
                }
                e.stopPropagation();
                console.log('Tag button clicked for image:', screenshot.name);
                ui.showTagManager(index);
            });
            
            // Add the div to the image list
            domElements.imageList.appendChild(div);
        });
        console.log('Image list updated.');
        // Update the size of images in the list
        ui.updateImageSize();

        // Show placeholder if there are no screenshots
        if (constants.screenshots.length === 0) {
            ui.showPlaceholder();
        } else {
            // Hide placeholder if it exists
            const placeholderMessage = document.getElementById('placeholderMessage');
            if (placeholderMessage) {
                placeholderMessage.style.display = 'none';
            }
        }
    },

    // Improved calculateSnapPosition function
    calculateSnapPosition: (movingBox, allBoxes, currentPosition) => {
        // Use a fixed threshold (or consider making it dynamic based on box size)
        const snapThreshold = constants.snapThreshold;
        let bestDeltaX = snapThreshold;
        let bestDeltaY = snapThreshold;
        let snapX = null;
        let snapY = null;
        
        // Get the image container's bounding rectangle
        const containerRect = domElements.imageContainer.getBoundingClientRect();
        
        // Get the current dimensions for the moving box
        const movingRect = movingBox.getBoundingClientRect();
        const movingWidth = movingRect.width;
        const movingHeight = movingRect.height;
        
        // Determine the current edges of the moving box (relative to the container)
        const movingEdges = {
            left: currentPosition.x,
            right: currentPosition.x + movingWidth,
            top: currentPosition.y,
            bottom: currentPosition.y + movingHeight,
            centerX: currentPosition.x + movingWidth / 2,
            centerY: currentPosition.y + movingHeight / 2
        };
        
        // Also allow snapping against the container edges
        const containerEdges = {
            left: 0,
            right: containerRect.width,
            top: 0,
            bottom: containerRect.height,
            centerX: containerRect.width / 2,
            centerY: containerRect.height / 2
        };
        
        // Check candidates for snapping to container edges (horizontal)
        [
            { delta: Math.abs(movingEdges.left - containerEdges.left), candidate: containerEdges.left },
            { delta: Math.abs(movingEdges.right - containerEdges.right), candidate: containerEdges.right - movingWidth }
        ].forEach(cand => {
            if (cand.delta < bestDeltaX) {
                bestDeltaX = cand.delta;
                snapX = cand.candidate;
            }
        });
        
        // Check candidates for snapping to container edges (vertical)
        [
            { delta: Math.abs(movingEdges.top - containerEdges.top), candidate: containerEdges.top },
            { delta: Math.abs(movingEdges.bottom - containerEdges.bottom), candidate: containerEdges.bottom - movingHeight }
        ].forEach(cand => {
            if (cand.delta < bestDeltaY) {
                bestDeltaY = cand.delta;
                snapY = cand.candidate;
            }
        });
        
        // Also snap to the image element edges if it exists inside the container
        const img = domElements.imageContainer.querySelector('img');
        if (img) {
            const imgRect = img.getBoundingClientRect();
            const imageRelativeLeft = imgRect.left - containerRect.left;
            const imageRelativeTop = imgRect.top - containerRect.top;
            const imageWidth = imgRect.width;
            const imageHeight = imgRect.height;
            const imageEdges = {
                left: imageRelativeLeft,
                right: imageRelativeLeft + imageWidth,
                top: imageRelativeTop,
                bottom: imageRelativeTop + imageHeight
            };

            // Check horizontal candidates for snapping to image edges
            [
                { delta: Math.abs(movingEdges.left - imageEdges.left), candidate: imageEdges.left },
                { delta: Math.abs(movingEdges.right - imageEdges.right), candidate: imageEdges.right - movingWidth }
            ].forEach(cand => {
                if (cand.delta < bestDeltaX) {
                    bestDeltaX = cand.delta;
                    snapX = cand.candidate;
                }
            });

            // Check vertical candidates for snapping to image edges
            [
                { delta: Math.abs(movingEdges.top - imageEdges.top), candidate: imageEdges.top },
                { delta: Math.abs(movingEdges.bottom - imageEdges.bottom), candidate: imageEdges.bottom - movingHeight }
            ].forEach(cand => {
                if (cand.delta < bestDeltaY) {
                    bestDeltaY = cand.delta;
                    snapY = cand.candidate;
                }
            });
        }
        
        // Get all boxes AND textboxes for snapping
        const allElements = Array.from(domElements.imageContainer.querySelectorAll('.box:not(.resizing), .textbox:not(.resizing)'));

        // Go through every other box and textbox in the container and calculate candidate snap positions
        allElements.forEach(otherElement => {
            if (otherElement !== movingBox) {
                const otherRect = otherElement.getBoundingClientRect();
                const otherRelativeLeft = otherRect.left - containerRect.left;
                const otherRelativeTop = otherRect.top - containerRect.top;
                const otherWidth = otherRect.width;
                const otherHeight = otherRect.height;
                
                const otherEdges = {
                    left: otherRelativeLeft,
                    right: otherRelativeLeft + otherWidth,
                    top: otherRelativeTop,
                    bottom: otherRelativeTop + otherHeight,
                    centerX: otherRelativeLeft + otherWidth / 2,
                    centerY: otherRelativeTop + otherHeight / 2
                };
                
                // Define horizontal snap candidates
                [
                    { delta: Math.abs(movingEdges.left - otherEdges.left), candidate: otherEdges.left },
                    { delta: Math.abs(movingEdges.right - otherEdges.right), candidate: otherEdges.right - movingWidth },
                    { delta: Math.abs(movingEdges.left - otherEdges.right), candidate: otherEdges.right },
                    { delta: Math.abs(movingEdges.right - otherEdges.left), candidate: otherEdges.left - movingWidth }
                ].forEach(cand => {
                    if (cand.delta < bestDeltaX) {
                        bestDeltaX = cand.delta;
                        snapX = cand.candidate;
                    }
                });
                
                // Define vertical snap candidates
                [
                    { delta: Math.abs(movingEdges.top - otherEdges.top), candidate: otherEdges.top },
                    { delta: Math.abs(movingEdges.bottom - otherEdges.bottom), candidate: otherEdges.bottom - movingHeight },
                    { delta: Math.abs(movingEdges.top - otherEdges.bottom), candidate: otherEdges.bottom },
                    { delta: Math.abs(movingEdges.bottom - otherEdges.top), candidate: otherEdges.top - movingHeight }
                ].forEach(cand => {
                    if (cand.delta < bestDeltaY) {
                        bestDeltaY = cand.delta;
                        snapY = cand.candidate;
                    }
                });
            }
        });
        
        // Only snap if the best found candidate is within the threshold
        const snapped = bestDeltaX < snapThreshold || bestDeltaY < snapThreshold;
        return { 
            snapX: (bestDeltaX < snapThreshold ? snapX : null), 
            snapY: (bestDeltaY < snapThreshold ? snapY : null), 
            snapped 
        };
    },
    
    // Delete a screenshot and update related data
    deleteScreenshot: (index) => {
        // Store the current tag filter value
        const currentTagFilter = document.getElementById('tagFilter').value;

        constants.boxes = constants.boxes.filter(box => box.screenshotIndex !== index);
        constants.boxes.forEach(box => {
            if (box.screenshotIndex > index) box.screenshotIndex--;
            if (box.linkedTo === index) box.linkedTo = null;
            else if (box.linkedTo > index) box.linkedTo--;
        });
        
        constants.screenshots.splice(index, 1);
        
        if (constants.currentScreenshotIndex === index) {
            constants.currentScreenshotIndex = Math.max(0, index - 1);
            if (constants.screenshots.length > 0) {
                core.displayScreenshot(constants.currentScreenshotIndex);
            } else {
                domElements.imageContainer.innerHTML = '';
                constants.currentScreenshot = null;
                ui.showPlaceholder();
            }
        } else if (constants.currentScreenshotIndex > index) {
            constants.currentScreenshotIndex--;
        }

        // Update the tag filter dropdown
        ui.updateTagFilter();
        
        // Restore the previously selected tag if it still exists
        const tagFilter = document.getElementById('tagFilter');
        if (Array.from(tagFilter.options).some(option => option.value === currentTagFilter)) {
            tagFilter.value = currentTagFilter;
        }

        core.updateImageList();
        core.displayBoxes();

        // Apply the current filter to update the image list view
        ui.applyCurrentFilter();
    },
    
    // Scale the displayed image to fit the container
    scaleImage: () => {
        console.log('Scaling image');
        // Get the dimensions of the container
        const containerWidth = domElements.imageContainer.clientWidth;
        const containerHeight = domElements.imageContainer.clientHeight;

        // Find the image element within the container
        const img = domElements.imageContainer.querySelector('img');
        if (!img) {
            //console.log('No image found in container');
            return;
        }

        // Get the natural dimensions of the image
        const imgNaturalWidth = img.naturalWidth;
        const imgNaturalHeight = img.naturalHeight;

        // NEW: Use the stored base dimensions if available, otherwise fall back to the image's natural dimensions.
        const baseWidth = constants.currentScreenshot.baseWidth || imgNaturalWidth;
        const baseHeight = constants.currentScreenshot.baseHeight || imgNaturalHeight;

        const scaleFactor = utils.calculateScaleFactor(baseWidth, baseHeight, containerWidth, containerHeight);
        
        // Apply the calculated dimensions to the image
        img.style.width = `${baseWidth * scaleFactor}px`;
        img.style.height = `${baseHeight * scaleFactor}px`;
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        img.style.objectFit = 'contain';

        // Update the scale in the current screenshot object
        if (constants.currentScreenshot) {
            constants.currentScreenshot.scale = scaleFactor;
        } else {
            console.log('currentScreenshot is null');
        }

        // Adjust the font size of box indicators based on box size
        const boxes = domElements.imageContainer.querySelectorAll('.box');
        boxes.forEach(box => {
            const width = parseFloat(box.style.width);
            const height = parseFloat(box.style.height);
            const minSize = Math.min(width, height);
            const indicatorScaleFactor = minSize / 100;
            const indicators = box.querySelector('.box-indicators');
            if (indicators) {
                // Set font size between 8px and 16px based on box size
                indicators.style.fontSize = `${Math.max(8, Math.min(16, indicatorScaleFactor * 12))}px`;
            }
        });

        // NEW: Iterate through textboxes and resize their content
        const textboxes = domElements.imageContainer.querySelectorAll('.textbox');
        textboxes.forEach(textbox => {
            core.resizeTextBoxContent(textbox);
        });
    },
    
    // Display boxes on the current screenshot
    
    displayBoxes: () => {
    // Remove all existing non-temporary boxes and textboxes
    const existingElements = domElements.imageContainer.querySelectorAll('.box:not(.temp-box), .textbox:not(.temp-textbox)');
    existingElements.forEach(el => el.remove());

    // Get the current image element
    const img = domElements.imageContainer.querySelector('img');
    if (!img) return;

    // Calculate offsets for box positioning
    const imgRect = img.getBoundingClientRect();
    const containerRect = domElements.imageContainer.getBoundingClientRect();
    
    const offsetX = imgRect.left - containerRect.left;
    const offsetY = imgRect.top - containerRect.top;

    const borderWidth = 2;

    // Function to create and display a box
    const displayBox = (box, isGlobal = false) => {
        // Skip if the box shouldn't be displayed on the current screenshot
        if (!isGlobal && box.screenshotIndex !== constants.currentScreenshotIndex) return;
        if (isGlobal && !box.visibleOn.includes(constants.currentScreenshotIndex)) return;

        // Create the box element
        const boxElement = document.createElement('div');
        boxElement.className = `box ${isGlobal ? 'global' : ''}`;
        if (box.linkedTo !== null && box.linkedTo !== undefined) boxElement.classList.add('linked');

        // Create indicators container
        const indicators = document.createElement('div');
        indicators.className = 'box-indicators';

        // Show/hide indicators based on UI visibility setting
        indicators.classList.add(constants.showUIElements ? 'show-indicators' : 'hide-indicators');
        
        // Add global indicator if the box is global
        if (isGlobal) {
            const globalIndicator = document.createElement('span');
            globalIndicator.className = 'indicator global-indicator';
            globalIndicator.innerHTML = '<i class="fas fa-globe"></i> Global';
            indicators.appendChild(globalIndicator);
        }
        
        // Add linked indicator if the box is linked
        if (box.linkedTo !== null && box.linkedTo !== undefined) {
            const linkedIndicator = document.createElement('span');
            linkedIndicator.className = 'indicator linked-indicator';
            linkedIndicator.innerHTML = '<i class="fas fa-link"></i> Linked';
            indicators.appendChild(linkedIndicator);
        }
        
        boxElement.appendChild(indicators);

        // Calculate and set box position and size
        const left = offsetX + (box.x * imgRect.width);
        const top = offsetY + (box.y * imgRect.height);
        const width = box.width * imgRect.width;
        const height = box.height * imgRect.height;

        boxElement.style.left = `${left}px`;
        boxElement.style.top = `${top}px`;
        boxElement.style.width = `${width}px`;
        boxElement.style.height = `${height}px`;

        // Add coordinate and dimension information
        const coordInfo = document.createElement('div');
        coordInfo.className = 'coord-info';
        coordInfo.innerHTML = `
            TL: (${box.x.toFixed(4)}, ${box.y.toFixed(4)})<br>
            BR: (${(box.x + box.width).toFixed(4)}, ${(box.y + box.height).toFixed(4)})<br>
            W: ${box.width.toFixed(4)}, H: ${box.height.toFixed(4)}
        `;
        coordInfo.style.position = 'absolute';
        coordInfo.style.top = '2px';
        coordInfo.style.left = '2px';
        coordInfo.style.fontSize = '10px';
        coordInfo.style.color = 'white';
        coordInfo.style.backgroundColor = 'rgba(0,0,0,0.7)';
        coordInfo.style.padding = '2px 4px';
        coordInfo.style.borderRadius = '3px';
        coordInfo.style.lineHeight = '1.2';
        coordInfo.style.display = 'none'; // Add this line to hide the coord-info
        boxElement.appendChild(coordInfo);

        // Position indicators
        indicators.style.position = 'absolute';
        indicators.style.top = '0';
        indicators.style.left = '0';
        indicators.style.transform = 'translate(0, -100%)';
        indicators.style.flexDirection = 'row';
        indicators.style.gap = '2px';

        // Scale indicators based on box size
        const minSize = Math.min(width, height);
        const scaleFactor = minSize / 100;
        indicators.style.fontSize = `${Math.max(8, Math.min(16, scaleFactor * 12))}px`;

        // Set data attributes for the box
        boxElement.setAttribute('data-x', box.x);
        boxElement.setAttribute('data-y', box.y);
        boxElement.setAttribute('data-width', box.width);
        boxElement.setAttribute('data-height', box.height);
        if (box.linkedTo !== null && box.linkedTo !== undefined) boxElement.setAttribute('data-linked-to', box.linkedTo);

        // Add event listeners
        boxElement.addEventListener('contextmenu', (e) => ui.showContextMenu(e, boxElement));
        boxElement.addEventListener('mousedown', (e) => {
            e.preventDefault();
        });

        boxElement.addEventListener('click', (e) => {
            // Navigate to linked screenshot if the box is linked and not recently moved
            if (Date.now() - constants.lastMoveTime > 200 && boxElement.classList.contains('linked')) {
                core.displayScreenshot(parseInt(boxElement.getAttribute('data-linked-to')));
            }
        });

        // Append the box to the image container
        domElements.imageContainer.appendChild(boxElement);
    };

    // Display regular boxes
    constants.boxes.forEach(box => displayBox(box));
    // Display global boxes
    constants.globalBoxes.forEach(box => displayBox(box, true));

    // NEW: Display text boxes for the current screenshot
    constants.textBoxes.forEach(textBox => {
        if (textBox.screenshotIndex === constants.currentScreenshotIndex) {
            core.createTextBoxElement(textBox);
        }
    });

    // NEW: Display global text boxes for the current screenshot
    constants.globalTextBoxes.forEach(textBox => {
        if (textBox.visibleOn.includes(constants.currentScreenshotIndex)) {
            core.createTextBoxElement(textBox);
        }
    });
},


    
    
    // Create a new box element
    createBoxElement: (box) => {
        // Create the main box element
        const boxElement = document.createElement('div');
        boxElement.className = 'box';
        if (box.isGlobal) boxElement.classList.add('global');
        if (box.linkedTo !== null && box.linkedTo !== undefined) boxElement.classList.add('linked');

        // Create indicators container
        const indicators = document.createElement('div');
        indicators.className = 'box-indicators';

        // Add global indicator if the box is global
        if (box.isGlobal) {
            const globalIndicator = document.createElement('span');
            globalIndicator.className = 'indicator global-indicator';
            globalIndicator.innerHTML = '<i class="fas fa-globe"></i> Global';
            indicators.appendChild(globalIndicator);
        }

        // Add linked indicator if the box is linked
        if (box.linkedTo !== null && box.linkedTo !== undefined) {
            const linkedIndicator = document.createElement('span');
            linkedIndicator.className = 'indicator linked-indicator';
            linkedIndicator.innerHTML = '<i class="fas fa-link"></i> Linked';
            indicators.appendChild(linkedIndicator);
        }

        // Append indicators to the box element
        boxElement.appendChild(indicators);

        // Get the image element
        const img = domElements.imageContainer.querySelector('img');
        if (img) {
            // Calculate box position and size based on image dimensions
            const imgRect = img.getBoundingClientRect();
            const containerRect = domElements.imageContainer.getBoundingClientRect();
            
            const offsetX = imgRect.left - containerRect.left;
            const offsetY = imgRect.top - containerRect.top;
            
            const borderWidth = 2;

            const left = offsetX + (box.x * imgRect.width);
            const top = offsetY + (box.y * imgRect.height);
            const width = box.width * imgRect.width;
            const height = box.height * imgRect.height;

            // Set box position and size
            boxElement.style.left = `${left - borderWidth / 2}px`;
            boxElement.style.top = `${top - borderWidth / 2}px`;
            boxElement.style.width = `${width}px`;
            boxElement.style.height = `${height}px`;
        }

        // Add coordinate and dimension information
        const coordInfo = document.createElement('div');
        coordInfo.className = 'coord-info';
        coordInfo.innerHTML = `
            TL: (${box.x.toFixed(4)}, ${box.y.toFixed(4)})<br>
            BR: (${(box.x + box.width).toFixed(4)}, ${(box.y + box.height).toFixed(4)})<br>
            W: ${box.width.toFixed(4)}, H: ${box.height.toFixed(4)}
        `;
        coordInfo.style.position = 'absolute';
        coordInfo.style.top = '2px';
        coordInfo.style.left = '2px';
        coordInfo.style.fontSize = '10px';
        coordInfo.style.color = 'white';
        coordInfo.style.backgroundColor = 'rgba(0,0,0,0.7)';
        coordInfo.style.padding = '2px 4px';
        coordInfo.style.borderRadius = '3px';
        coordInfo.style.lineHeight = '1.2';
        coordInfo.style.display = 'none'; // Add this line to hide the coord-info
        boxElement.appendChild(coordInfo);

        // Set data attributes for the box
        boxElement.setAttribute('data-x', box.x);
        boxElement.setAttribute('data-y', box.y);
        boxElement.setAttribute('data-width', box.width);
        boxElement.setAttribute('data-height', box.height);
        if (box.linkedTo !== null && box.linkedTo !== undefined) boxElement.setAttribute('data-linked-to', box.linkedTo);

        // Add event listeners
        boxElement.addEventListener('contextmenu', (e) => ui.showContextMenu(e, boxElement));
        boxElement.addEventListener('mousedown', (e) => {
            e.preventDefault();
        });

        boxElement.addEventListener('click', (e) => {
            // Navigate to linked screenshot if applicable
            if (Date.now() - constants.lastMoveTime > 200 && boxElement.classList.contains('linked')) {
                core.displayScreenshot(parseInt(boxElement.getAttribute('data-linked-to')));
            }
        });

        // Append the box to the image container
        domElements.imageContainer.appendChild(boxElement);
        return boxElement;
        },
    
    // Start drawing a new box
    startDrawing: (e) => {
        if (constants.isDrawing) {
            const rect = domElements.imageContainer.getBoundingClientRect();
            constants.startX = e.clientX - rect.left;
            constants.startY = e.clientY - rect.top;
        }
    },

    // Draw a box as the user moves the mouse
    drawBox: (e) => {
        if (constants.isDrawing && constants.startX !== null && constants.startY !== null) {
            const rect = domElements.imageContainer.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            let tempBox = domElements.imageContainer.querySelector('.temp-box') || core.createTempBox();
            
            const left = Math.min(constants.startX, currentX);
            const top = Math.min(constants.startY, currentY);
            const width = Math.abs(currentX - constants.startX);
            const height = Math.abs(currentY - constants.startY);
            
            Object.assign(tempBox.style, { 
                left: `${left}px`, 
                top: `${top}px`, 
                width: `${width}px`, 
                height: `${height}px`,
                display: 'block'
            });
        }
    },

    // Finish drawing a box
    endDrawing: () => {
        if (constants.isDrawing) {
            // Check if an image exists. If not, reset drawing state and exit.
            const img = domElements.imageContainer.querySelector('img');
            if (!img) {
                console.log("No image loaded. Exiting draw-box mode.");
                constants.isDrawing = false;
                domElements.imageContainer.style.cursor = 'default';
                domElements.drawBoxBtn.classList.remove('active');
                return;
            }
            const tempBox = domElements.imageContainer.querySelector('.temp-box');
            if (tempBox) {
                const width = parseFloat(tempBox.style.width);
                const height = parseFloat(tempBox.style.height);
        
                // If the drawn box is sufficiently large, use image dimensions.
                if (width >= 10 && height >= 10) {
                    const imgRect = img.getBoundingClientRect();
                    const containerRect = domElements.imageContainer.getBoundingClientRect();
                    const offsetX = imgRect.left - containerRect.left;
                    const offsetY = imgRect.top - containerRect.top;
        
                    const box = {
                        x: (parseFloat(tempBox.style.left) - offsetX) / imgRect.width,
                        y: (parseFloat(tempBox.style.top) - offsetY) / imgRect.height,
                        width: width / imgRect.width,
                        height: height / imgRect.height,
                        linkedTo: null,
                        screenshotIndex: constants.currentScreenshotIndex
                    };
                    constants.boxes.push(box);
                    core.createBoxElement(box);
                    core.updateBoxCounts();
                }
                // Remove the temporary box
                tempBox.remove();
            }
        
            // Reset drawing state
            constants.isDrawing = false;
            domElements.imageContainer.style.cursor = 'default';
            domElements.drawBoxBtn.classList.remove('active');
            constants.startX = null;
            constants.startY = null;
        }
        if (!domElements.imageList.classList.contains('linking')) {
            ui.hideModeIndicator();
        }
    },

    // Create a temporary box element while drawing
    createTempBox: () => {
        const tempBox = document.createElement('div');
        tempBox.className = 'box temp-box';
        tempBox.style.display = 'none';
        domElements.imageContainer.appendChild(tempBox);
        return tempBox;
    },

    // Display a specific screenshot
    displayScreenshot: (index) => {
        console.group("Display Screenshot");
        console.log(`Now displaying screenshot at index: ${index} - ${constants.screenshots[index]?.name}`);
        console.groupEnd();
        // Check if the index is valid
        if (index < 0 || index >= constants.screenshots.length) {
            return;
        }
        // Set the current screenshot and index
        constants.currentScreenshot = constants.screenshots[index];
        constants.currentScreenshotIndex = index;
        
        // Update the active state of image items in the sidebar
        const imageItems = domElements.imageList.querySelectorAll('.image-item');
        imageItems.forEach((item, i) => {
            item.classList.toggle('active', i === index);
        });
        
        // Hide the placeholder message if it exists
        const placeholderMessage = document.getElementById('placeholderMessage');
        if (placeholderMessage) {
            placeholderMessage.style.display = 'none';
        }
        
        // Clear the image container
        domElements.imageContainer.innerHTML = '';
        
        // Create and display a loading indicator
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.textContent = 'Loading...';
        domElements.imageContainer.appendChild(loadingDiv);
        
        // Create a new Image object and set up its onload handler
        const img = new Image();
        img.onload = function() {
            // Clear the image container and add the loaded image
            domElements.imageContainer.innerHTML = '';
            domElements.imageContainer.appendChild(img);
            
            // NEW: Set base dimensions from the first load
            if (!constants.currentScreenshot.baseWidth) {
                constants.currentScreenshot.baseWidth = img.naturalWidth;
                constants.currentScreenshot.baseHeight = img.naturalHeight;
            }
            
            // Scale the image, display boxes, and prevent dragging
            core.scaleImage();
            core.displayBoxes();
            ui.preventImageDrag();
            
            // NEW: Update box counts for the newly displayed image
            core.updateBoxCounts();
        };
        // Set the image source and alt text
        img.src = constants.currentScreenshot.data;
        img.alt = "Screenshot";
        
        // Update the active image state in the UI
        ui.updateActiveImageState(index);
        
        // Apply the current filter to the image
        ui.applyCurrentFilter();
    },

    // Initialize the application
    initializeApp: () => {
        // Add loading styles to the UI
        ui.addLoadingStyles();

        // Check if project data is available in the DOM
        const projectDataScript = document.getElementById('projectData');
        if (projectDataScript) {
            // If project data exists, parse and load it
            const projectData = JSON.parse(projectDataScript.textContent);
            core.loadProjectData(projectData, false);
        } else {
            // If no project data, set up initial UI state
            constants.showUIElements = true;
            ui.updateUIVisibility();
            ui.updateImageSize();
            
            // Create or update placeholder message for empty state
            let placeholderMessage = document.getElementById('placeholderMessage');
            if (!placeholderMessage) {
                // Create new placeholder message if it doesn't exist
                placeholderMessage = document.createElement('div');
                placeholderMessage.id = 'placeholderMessage';
                placeholderMessage.className = 'placeholder-message';
                placeholderMessage.innerHTML = `
                    <div class="placeholder-content">
                        <i class="fas fa-image fa-10x"></i>
                        <h2>No Images Added</h2>
                        <p>Upload screenshots to get started</p>
                        <p>Click the <i class="fas fa-upload"></i> button in the sidebar</p>
                    </div>
                `;
                domElements.imageContainer.appendChild(placeholderMessage);
            }

            // Show or hide placeholder message based on screenshot availability
            if (constants.screenshots.length === 0) {
                placeholderMessage.style.display = 'block';
            } else {
                placeholderMessage.style.display = 'none';
            }
        }
    },

    // Load project data
    loadProjectData: (projectData, forceShowUI = false) => {
        // NEW: Set project mode for saved project so textboxes become read-only when not editing.
        constants.isSavedProject = projectData.isSavedProject || false;
        if (forceShowUI) {
            // When reopening project for editing, force interactive mode.
            constants.isSavedProject = false;
        }
        
        // Set UI visibility based on forceShowUI or project data
        constants.showUIElements = forceShowUI ? true : projectData.showUIElements;
        ui.updateUIVisibility();
        ui.updateImageSize();
        
        // Map screenshots from project data to constants, including tags
        constants.screenshots = projectData.screenshots.map(screenshot => ({
            name: screenshot.name,
            data: screenshot.data,
            tags: screenshot.tags || []  // Use empty array if tags are not present
        }));

        // --- NEW CODE: Create index mapping ---
        const oldIndexToNewIndex = new Map();
        projectData.screenshots.forEach((oldScreenshot, oldIndex) => {
            // --- UPDATED: Use both name AND data for uniqueness ---
            const newIndex = constants.screenshots.findIndex(s => s.name === oldScreenshot.name && s.data === oldScreenshot.data);
            oldIndexToNewIndex.set(oldIndex, newIndex);
        });
        // --- END NEW CODE ---
        
        // Map boxes from project data to constants, ensuring linkedTo is null if not set
        constants.boxes = projectData.boxes.map(box => ({
            ...box,
            // --- UPDATED CODE: Use the mapping to update linkedTo ---
            linkedTo: box.linkedTo !== null ? oldIndexToNewIndex.get(box.linkedTo) : null,
            screenshotIndex: oldIndexToNewIndex.get(box.screenshotIndex)
            // --- END UPDATED CODE ---
        }));
        
        // Map global boxes from project data to constants, ensuring linkedTo is null if not set
        constants.globalBoxes = projectData.globalBoxes.map(box => ({
            ...box,
            // --- UPDATED CODE: Use the mapping to update linkedTo and visibleOn ---
            linkedTo: box.linkedTo !== null ? oldIndexToNewIndex.get(box.linkedTo) : null,
            visibleOn: box.visibleOn.map(oldIndex => oldIndexToNewIndex.get(oldIndex))
            // --- END UPDATED CODE ---
        }));
        
        // Set the current screenshot to the first one
        constants.currentScreenshotIndex = 0;
        constants.currentScreenshot = constants.screenshots[constants.currentScreenshotIndex];
        
        // Update box colors if provided in project data
        if (projectData.linkedBoxColor) {
            constants.linkedBoxColor = projectData.linkedBoxColor;
        }
        if (projectData.globalBoxColor) {
            constants.globalBoxColor = projectData.globalBoxColor;
        }
        ui.updateBoxStyles();
        
        // Update UI elements
        core.updateImageList();
        core.displayScreenshot(constants.currentScreenshotIndex);
        ui.updateImageSize();
        ui.updateTagFilterDropdown();
        
        // Add validation log to confirm project data is loaded correctly
        console.group("Project Data Validation");
        console.log(`Total screenshots: ${constants.screenshots.length}`);
        console.log(`Total boxes: ${constants.boxes.length}`);
        console.log(`Total global boxes: ${constants.globalBoxes.length}`);
        console.groupEnd();
    
        // NEW: Map text boxes from project data (if available)
        constants.textBoxes = projectData.textBoxes ? projectData.textBoxes.map(textBox => ({
            ...textBox,
            // --- UPDATED CODE: Use mapping for textboxes ---
            screenshotIndex: oldIndexToNewIndex.get(textBox.screenshotIndex)
            // --- END UPDATED CODE ---
        })) : [];

        constants.globalTextBoxes = projectData.globalTextBoxes ? projectData.globalTextBoxes.map(textBox => ({
            ...textBox,
            // --- UPDATED CODE: Use mapping for global textboxes ---
            visibleOn: textBox.visibleOn.map(oldIndex => oldIndexToNewIndex.get(oldIndex))
            // --- END UPDATED CODE ---
        })) : [];
    },

    // Toggle a box between global and local
    toggleGlobalBox: (box) => {
        const isGlobal = box.classList.contains('global');
        const toggleButton = document.getElementById('toggleGlobalBox');
        
        const boxData = isGlobal 
            ? constants.globalBoxes.find(b => 
                b.x === parseFloat(box.getAttribute('data-x')) && 
                b.y === parseFloat(box.getAttribute('data-y')))
            : constants.boxes.find(b => 
                b.screenshotIndex === constants.currentScreenshotIndex && 
                b.x === parseFloat(box.getAttribute('data-x')) && 
                b.y === parseFloat(box.getAttribute('data-y')));
        
        if (boxData) {
            if (isGlobal) {
                // Convert global box to local
                const localBox = {
                    ...boxData,
                    isGlobal: false,
                    screenshotIndex: constants.currentScreenshotIndex
                };
                delete localBox.visibleOn;
                constants.boxes.push(localBox);
                
                const globalIndex = constants.globalBoxes.findIndex(b => b === boxData);
                if (globalIndex !== -1) {
                    constants.globalBoxes.splice(globalIndex, 1);
                }
                
                toggleButton.classList.remove('active');
            } else {
                // Convert local box to global
                // UPDATED: Set `visibleOn` to all screenshot indices.
                const globalBox = {
                    ...boxData,
                    isGlobal: true,
                    visibleOn: Array.from({ length: constants.screenshots.length }, (_, i) => i)
                };
                delete globalBox.screenshotIndex;
                constants.globalBoxes.push(globalBox);
                
                const localIndex = constants.boxes.findIndex(b => b === boxData);
                if (localIndex !== -1) {
                    constants.boxes.splice(localIndex, 1);
                }
                
                toggleButton.classList.add('active');
            }
            core.displayBoxes();
        }
        
        domElements.contextMenu.classList.add('hidden');
        core.updateBoxCounts();
        
    },


    // Initialize image dimensions
    initializeImageDimensions: () => {
        const img = domElements.imageContainer.querySelector('img');
        if (img) {
            img.onload = () => {
                core.scaleImage();
                core.displayBoxes();
            };
        }
    },

    // Initialize drawing functionality
    initializeDrawing: () => {
        const tempBox = domElements.imageContainer.querySelector('.temp-box');
        if (tempBox) {
            tempBox.remove();
        }
        core.createTempBox();
    },

    // NEW: Start drawing a text box (similar to startDrawing)
    startDrawingText: (e) => {
        if (constants.isDrawingText) {
            const rect = domElements.imageContainer.getBoundingClientRect();
            constants.textStartX = e.clientX - rect.left;
            constants.textStartY = e.clientY - rect.top;
            // Create a temporary text box element
            let tempTextBox = domElements.imageContainer.querySelector('.temp-textbox');
            if (!tempTextBox) {
                tempTextBox = document.createElement('div');
                tempTextBox.className = 'textbox temp-textbox';
                // You may want a dashed border or different style for the temporary text box
                tempTextBox.style.border = '2px dashed var(--textbox-color)';
                tempTextBox.style.position = 'absolute';
                domElements.imageContainer.appendChild(tempTextBox);
            }
        }
    },

    // NEW: Draw text box while moving the mouse (similar to drawBox)
    drawTextBox: (e) => {
        if (constants.isDrawingText && constants.textStartX !== null && constants.textStartY !== null) {
            const rect = domElements.imageContainer.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            let tempTextBox = domElements.imageContainer.querySelector('.temp-textbox');
            if (!tempTextBox) {
                tempTextBox = document.createElement('div');
                tempTextBox.className = 'textbox temp-textbox';
                domElements.imageContainer.appendChild(tempTextBox);
            }
            const left = Math.min(constants.textStartX, currentX);
            const top = Math.min(constants.textStartY, currentY);
            const width = Math.abs(currentX - constants.textStartX);
            const height = Math.abs(currentY - constants.textStartY);
            Object.assign(tempTextBox.style, {
                left: `${left}px`,
                top: `${top}px`,
                width: `${width}px`,
                height: `${height}px`,
                display: 'block'
            });
        }
    },

    // NEW: End drawing the text box (similar to endDrawing)
    endDrawingText: () => {
        if (constants.isDrawingText) {
            const tempTextBox = domElements.imageContainer.querySelector('.temp-textbox');
            if (tempTextBox) {
                const width = parseFloat(tempTextBox.style.width);
                const height = parseFloat(tempTextBox.style.height);
                if (width >= 20 && height >= 20) { // require a minimum size
                    const img = domElements.imageContainer.querySelector('img');
                    if (img) {
                        const imgRect = img.getBoundingClientRect();
                        const containerRect = domElements.imageContainer.getBoundingClientRect();
                        const offsetX = imgRect.left - containerRect.left;
                        const offsetY = imgRect.top - containerRect.top;
                        const textBox = {
                            x: (parseFloat(tempTextBox.style.left) - offsetX) / imgRect.width,
                            y: (parseFloat(tempTextBox.style.top) - offsetY) / imgRect.height,
                            width: width / imgRect.width,
                            height: height / imgRect.height,
                            linkedTo: null,       // support linking just like boxes
                            screenshotIndex: constants.currentScreenshotIndex,
                            text: ''              // start with empty text
                        };
                        // Add new textbox to our array
                        constants.textBoxes.push(textBox);
                        core.createTextBoxElement(textBox);
                        core.updateBoxCounts(); // Add this line to update the box counts
                    }
                }
                tempTextBox.remove();
            }
            constants.isDrawingText = false;
            constants.textStartX = null;
            constants.textStartY = null;
            // Reset the cursor and mode indicator
            domElements.imageContainer.style.cursor = 'default';
            ui.hideModeIndicator();
        }
    },

    // NEW: Create and display a text box element on the image
    createTextBoxElement: (textBox) => {
        const boxElement = document.createElement('div');
        boxElement.className = 'textbox';
        if (textBox.linkedTo !== null && textBox.linkedTo !== undefined) {
            boxElement.classList.add('linked');
        }
        
        // Create a contenteditable inner element for typing text
        const contentDiv = document.createElement('div');
        contentDiv.className = 'textbox-content';
        contentDiv.contentEditable = true;
        contentDiv.textContent = textBox.text || 'Enter text here';
        
        // NEW: Add a wrapper div for scaling
        const wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'textbox-wrapper';
        wrapperDiv.appendChild(contentDiv);
        boxElement.appendChild(wrapperDiv);
        
        // NEW: When the project is saved make textboxes non-editable
        if (constants.isSavedProject) {
            contentDiv.contentEditable = false;
            boxElement.style.border = 'none';
            boxElement.style.boxShadow = 'none';
        } else {
            // Normal operation: allow editing and add focus/blur events
            contentDiv.addEventListener('focus', function() {
                if (contentDiv.textContent === 'Enter text here') {
                    contentDiv.textContent = '';
                }
                let range = document.createRange();
                range.selectNodeContents(contentDiv);
                range.collapse(false);
                let sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            });

            contentDiv.addEventListener('blur', function() {
                if (contentDiv.textContent.trim() === '') {
                    contentDiv.textContent = 'Enter text here';
                }
                textBox.text = contentDiv.textContent;
                setTimeout(() => {
                    const sel = window.getSelection();
                    if (sel) sel.removeAllRanges();
                }, 0);
            });
        }

        // Position the textbox
        const img = domElements.imageContainer.querySelector('img');
        if (!img) return;
        
        const imgRect = img.getBoundingClientRect();
        const containerRect = domElements.imageContainer.getBoundingClientRect();
        const offsetX = imgRect.left - containerRect.left;
        const offsetY = imgRect.top - containerRect.top;
        
        const left = offsetX + (textBox.x * imgRect.width);
        const top = offsetY + (textBox.y * imgRect.height);
        const width = textBox.width * imgRect.width;
        const height = textBox.height * imgRect.height;

        boxElement.style.left = `${left}px`;
        boxElement.style.top = `${top}px`;
        boxElement.style.width = `${width}px`;
        boxElement.style.height = `${height}px`;

        // Set data attributes
        boxElement.setAttribute('data-x', textBox.x);
        boxElement.setAttribute('data-y', textBox.y);
        boxElement.setAttribute('data-width', textBox.width);
        boxElement.setAttribute('data-height', textBox.height);
        
        // Add event listeners
        boxElement.addEventListener('contextmenu', (e) => ui.showContextMenu(e, boxElement));
        boxElement.addEventListener('click', (e) => {
            if (!constants.isSavedProject && boxElement.classList.contains('textbox')) {
                const content = boxElement.querySelector('.textbox-content');
                if (content) {
                    content.focus();
                }
            }
        });
        
        domElements.imageContainer.appendChild(boxElement);

        // NEW: Call resizeTextBoxContent to set initial text size
        core.resizeTextBoxContent(boxElement);

        return boxElement;
    },

    // Cancel current active operations
    cancelCurrentOperation: () => {
        // Cancel move mode
        if (constants.isMoving && constants.movingBox) {
            if (constants.isCopyMode) {
                // Remove the new copied box if in copy mode and also remove its data from our array
                constants.movingBox.remove();
                if (constants.movingBox.classList.contains('global')) {
                    // Remove from the globalBoxes array (assuming the new box was pushed last)
                    constants.globalBoxes.pop();
                } else {
                    // Remove from the local boxes array
                    constants.boxes.pop();
                }
                constants.isCopyMode = false;
            } else {
                // Revert to the original position if not in copy mode
                if (constants.originalBoxPosition) {
                    constants.movingBox.style.left = constants.originalBoxPosition.left;
                    constants.movingBox.style.top = constants.originalBoxPosition.top;
                }
            }
            if (constants.currentMoveHandlers) {
                document.removeEventListener('mousemove', constants.currentMoveHandlers.moveHandler);
                document.removeEventListener('mouseup', constants.currentMoveHandlers.stopMoving);
                constants.currentMoveHandlers = null;
            }
            constants.isMoving = false;
            constants.movingBox.classList.remove('moving');
            ui.hideModeIndicator();
        }
        // Cancel resizing mode
        if (constants.isResizing && constants.resizingBox) {
            // Revert to original dimensions
            if (constants.originalBoxDimensions) {
                constants.resizingBox.style.width = constants.originalBoxDimensions.width;
                constants.resizingBox.style.height = constants.originalBoxDimensions.height;
            }
            if (constants.currentResizeHandlers) {
                document.removeEventListener('mousemove', constants.currentResizeHandlers.resizeHandler);
                document.removeEventListener('mouseup', constants.currentResizeHandlers.stopResizing);
                constants.currentResizeHandlers = null;
            }
            constants.isResizing = false;
            const handle = constants.resizingBox.querySelector('.resize-handle');
            if (handle) {
                handle.remove();
            }
            constants.resizingBox.classList.remove('resizing');
            ui.hideModeIndicator();
        }
        // Cancel link mode
        if (constants.isLinkMode) {
            document.body.classList.remove('link-mode-cursor');
            domElements.imageContainer.classList.remove('link-mode-cursor');
            domElements.imageList.classList.remove('linking');
            const linkMessageOverlay = document.querySelector('.link-message-overlay');
            if (linkMessageOverlay) {
                linkMessageOverlay.remove();
            }
            if (constants.currentLinkHandler) {
                domElements.imageList.removeEventListener('click', constants.currentLinkHandler);
                constants.currentLinkHandler = null;
            }
            constants.isLinkMode = false;
            ui.hideModeIndicator();
        }
    },

    updateBoxCounts: () => {
        // Count boxes for current screenshot only
        const currentIndex = constants.currentScreenshotIndex;
        
        // Only proceed if we have a valid current index
        if (currentIndex === -1) {
            // If no image is selected, set all counts to 0
            document.querySelector('.local-count span').textContent = '0';
            document.querySelector('.linked-count span').textContent = '0';
            document.querySelector('.global-count span').textContent = '0';
            document.querySelector('.text-count span').textContent = '0';
            return;
        }
        
        // Local boxes (excluding linked)
        const localCount = constants.boxes.filter(box => 
            box.screenshotIndex === currentIndex && box.linkedTo === null
        ).length;
        
        // Linked boxes
        const linkedCount = constants.boxes.filter(box => 
            box.screenshotIndex === currentIndex && box.linkedTo !== null
        ).length;
        
        // Global boxes visible on current screenshot
        const globalCount = constants.globalBoxes.filter(box =>
            box.visibleOn.includes(currentIndex)
        ).length;
        
        // Text boxes (both local and global) for current screenshot only
        const localTextCount = constants.textBoxes.filter(box =>
            box.screenshotIndex === currentIndex
        ).length;
        const globalTextCount = constants.globalTextBoxes.filter(box =>
            box.visibleOn.includes(currentIndex)
        ).length;
        const totalTextCount = localTextCount + globalTextCount;
        
        // Update the display
        document.querySelector('.local-count span').textContent = localCount;
        document.querySelector('.linked-count span').textContent = linkedCount;
        document.querySelector('.global-count span').textContent = globalCount;
        document.querySelector('.text-count span').textContent = totalTextCount;
    },

    // NEW: Function to resize the text content within a textbox
    resizeTextBoxContent: (textBoxElement) => {
        const contentDiv = textBoxElement.querySelector('.textbox-content');
        if (!contentDiv) return;

        const wrapperDiv = textBoxElement.querySelector('.textbox-wrapper');
        if (!wrapperDiv) return;

        const boxWidth = parseFloat(textBoxElement.style.width);
        const boxHeight = parseFloat(textBoxElement.style.height);

        const baseFontSize = 16; // Base font size in pixels
        const minFontSize = 8;   // Minimum font size in pixels

        // Calculate scale based on the smaller dimension of the box
        const scaleFactor = Math.min(boxWidth, boxHeight) / 100; // 100 is a reference size
        const fontSize = Math.max(minFontSize, baseFontSize * scaleFactor);

        // Apply the calculated font size
        contentDiv.style.fontSize = `${fontSize}px`;

        // Reset transform and dimensions before recalculating
        wrapperDiv.style.transform = 'none';
        wrapperDiv.style.width = 'auto';
        wrapperDiv.style.height = 'auto';

        // Get the natural dimensions of the content
        const contentWidth = contentDiv.offsetWidth;
        const contentHeight = contentDiv.offsetHeight;

        // Calculate scale factors for width and height independently
        const scaleX = boxWidth / contentWidth;
        const scaleY = boxHeight / contentHeight;

        // Use the smaller scale factor to ensure the content fits within the box
        const finalScale = Math.min(scaleX, scaleY);

        // Apply the final scale and adjust wrapper dimensions
        wrapperDiv.style.transform = `scale(${finalScale})`;
        wrapperDiv.style.width = `${100 / finalScale}%`;
        wrapperDiv.style.height = `${100 / finalScale}%`;
        wrapperDiv.style.transformOrigin = 'top left'; // Ensure consistent scaling
    },
};

// UI Functions
// This object contains functions related to user interface interactions
const ui = {
    // Show placeholder when no images are present
    showPlaceholder: () => {
        let placeholderMessage = document.getElementById('placeholderMessage');
        const sideToolbarWrapper = document.getElementById('sideToolbarWrapper');
        const isSidebarHidden = sideToolbarWrapper.classList.contains('hidden');

        if (!placeholderMessage) {
            placeholderMessage = document.createElement('div');
            placeholderMessage.id = 'placeholderMessage';
            placeholderMessage.className = 'placeholder-message';
        }

        placeholderMessage.innerHTML = `
            <div class="placeholder-content">
                <i class="fas fa-image fa-10x"></i>
                <h2>No Images Added</h2>
                <p>${isSidebarHidden ? 'Open the sidebar to get started' : 'Upload screenshots to get started'}</p>
                <p>${isSidebarHidden ? 
                    'Click the <i class="fas fa-chevron-right glow-indicator"></i> button to open the sidebar' : 
                    'Click the <i class="fas fa-upload glow-indicator"></i> button to upload images'}</p>
            </div>
        `;
        
        placeholderMessage.style.display = 'flex';
        domElements.imageContainer.appendChild(placeholderMessage);

        ui.updateGlowIndicators();
    },

    showHelpModal: () => {
        domElements.helpModal.classList.remove('hidden');
        // Add both mousedown and mouseup listeners
        domElements.helpModal.addEventListener('mousedown', ui.modalMouseDown);
        domElements.helpModal.addEventListener('mouseup', ui.closeModal);
    },

    showSettingsModal: () => {
        domElements.settingsModal.classList.remove('hidden');
        domElements.settingsModal.addEventListener('mousedown', ui.modalMouseDown);
        domElements.settingsModal.addEventListener('mouseup', ui.closeModal);
    },

    // In the ui object, add this new function for mousedown on modal overlay
    modalMouseDown: (event) => {
        // If mousedown happens directly on the overlay (not on modal content)
        if (event.target === event.currentTarget) {
            event.currentTarget.dataset.mousedownOutside = 'true';
        } else {
            event.currentTarget.dataset.mousedownOutside = 'false';
        }
    },
    
    // Update the closeModal handler to check if both mousedown and mouseup are on the overlay
    closeModal: (event) => {
        // Only proceed if mouseup occurred on the overlay and mousedown also started there
        if (
            event.type === 'mouseup' &&
            event.target === event.currentTarget &&
            event.currentTarget.dataset.mousedownOutside === 'true'
        ) {
            event.currentTarget.classList.add('hidden');
            event.currentTarget.removeEventListener('mousedown', ui.modalMouseDown);
            event.currentTarget.removeEventListener('mouseup', ui.closeModal);
            // Save settings if closing the settings modal
            if (event.currentTarget === domElements.settingsModal) {
                ui.saveSettings();
            }
        }
        // Clear the flag
        event.currentTarget.dataset.mousedownOutside = '';
    },
    
    saveSettings: () => {
        constants.drawBoxShortcut = ui.parseShortcut(domElements.drawBoxShortcutInput.value);
        constants.linkedBoxColor = domElements.linkedBoxColorInput.value;
        constants.globalBoxColor = domElements.globalBoxColorInput.value;
        ui.updateBoxStyles();
    },
    
    // Update the size of image thumbnails
    updateImageSize: () => {
        const containerWidth = domElements.sideToolbar.clientWidth - 10;
        const sliderValue = parseInt(domElements.imageSizeSlider.value);
        
        let imagesPerRow = 6 - sliderValue;
        let optimalSize = constants.imageSizes[sliderValue - 1];
        
        const imageItems = document.querySelectorAll('.image-item');
        
        // Remove transition-related code for image items
        imageItems.forEach(item => {
            item.style.width = `${optimalSize}px`;
            item.style.height = `${optimalSize}px`;

            // Adjust action button sizes
            const actionButtons = item.querySelectorAll('.image-actions button');
            const buttonSize = 20 + (sliderValue - 1) * 5;
            const fontSize = 10 + (sliderValue - 1) * 2;

            actionButtons.forEach(button => {
                button.style.width = `${buttonSize}px`;
                button.style.height = `${buttonSize}px`;
                button.style.fontSize = `${fontSize}px`;
            });
        });

        const totalImagesWidth = optimalSize * imagesPerRow;
        
        // Remove transitions from image list
        domElements.imageList.style.width = `${totalImagesWidth}px`;
        domElements.imageList.style.marginLeft = `${(containerWidth - totalImagesWidth) / 2}px`;
    },
    
    // Toggle the sidebar visibility
     toggleSidebar: () => {
        const sideToolbarWrapper = document.getElementById('sideToolbarWrapper');
        const imageContainer = document.getElementById('imageContainer');
        const sideToolbarToggle = document.getElementById('sideToolbarToggle');
    
        // Pre-calculate the new container dimensions
        const isHiding = !sideToolbarWrapper.classList.contains('hidden');
        const newMarginLeft = isHiding ? '20px' : '300px';
        
        // Function to perform scaling and box updates together
        const updateImageAndBoxes = () => {
            // Temporarily disable transitions on boxes to prevent animation lag
            const boxes = document.querySelectorAll('.box, .textbox');
            boxes.forEach(box => {
                box.style.transition = 'none';
            });

            // Force layout recalculation
            imageContainer.style.marginLeft = newMarginLeft;
            imageContainer.offsetHeight;

            // Scale image and update boxes in the same frame
            core.scaleImage();
            core.displayBoxes();

            // Re-enable transitions after a brief delay
            requestAnimationFrame(() => {
                boxes.forEach(box => {
                    box.style.transition = '';
                });
            });
        };

        // Add transition end listener
        const handleTransitionEnd = (e) => {
            if (e.target === sideToolbarWrapper) {
                sideToolbarWrapper.removeEventListener('transitionend', handleTransitionEnd);
                updateImageAndBoxes();
                ui.recalculateImageListLayout();
            }
        };
        sideToolbarWrapper.addEventListener('transitionend', handleTransitionEnd);

        // Toggle sidebar state
        sideToolbarWrapper.classList.toggle('hidden');
        
        if (sideToolbarWrapper.classList.contains('hidden')) {
            sideToolbarWrapper.style.transform = 'translateX(-280px)';
            sideToolbarToggle.style.left = '0px';
        } else {
            sideToolbarWrapper.style.transform = 'translateX(0)';
            sideToolbarToggle.style.left = '280px';
        }

        // Perform initial update
        updateImageAndBoxes();

        ui.updateGlowIndicators();

        const placeholderMessage = document.getElementById('placeholderMessage');
        if (placeholderMessage && placeholderMessage.style.display !== 'none') {
            ui.showPlaceholder();
        }

        // Fallback update
        setTimeout(() => {
            updateImageAndBoxes();
            ui.recalculateImageListLayout();
        }, 0);
    },
    
    // Update glow indicators for UI elements
    updateGlowIndicators: () => {
        const placeholderMessage = document.getElementById('placeholderMessage');
        const uploadBtn = document.querySelector('.upload-btn');
        const sideToolbarWrapper = document.getElementById('sideToolbarWrapper');
        const sideToolbarToggle = document.getElementById('sideToolbarToggle');

        if (placeholderMessage && placeholderMessage.style.display !== 'none') {
            if (sideToolbarWrapper.classList.contains('hidden')) {
                sideToolbarToggle.classList.add('glow-indicator');
                uploadBtn.classList.remove('glow-indicator');
                placeholderMessage.querySelector('p:last-child').innerHTML = 
                    'Click the <i class="fas fa-chevron-right glow-indicator"></i> button to open the sidebar';
            } else {
                sideToolbarToggle.classList.remove('glow-indicator');
                uploadBtn.classList.add('glow-indicator');
                placeholderMessage.querySelector('p:last-child').innerHTML = 
                    'Click the <i class="fas fa-upload glow-indicator"></i> button to upload images';
            }
        } else {
            sideToolbarToggle.classList.remove('glow-indicator');
            uploadBtn.classList.remove('glow-indicator');
        }
    },
    
    // Handle window resize events
    handleResize: () => {
        const now = Date.now();
        
        // If we're resizing too frequently, skip this update
        if (now - constants.lastResizeTime < constants.resizeThrottleTime) {
            return;
        }
        
        constants.lastResizeTime = now;

        // Temporarily disable transitions on boxes
        const boxes = document.querySelectorAll('.box, .textbox');
        boxes.forEach(box => {
            box.style.transition = 'none';
        });
        
        // Use requestAnimationFrame for smoother updates
        requestAnimationFrame(() => {
            // Only update sidebar position if it's visible
            const sideToolbarWrapper = document.getElementById('sideToolbarWrapper');
            if (sideToolbarWrapper.classList.contains('hidden')) {
                domElements.imageContainer.style.marginLeft = '20px';
                domElements.sideToolbarToggle.style.left = '0px';
            } else {
                domElements.imageContainer.style.marginLeft = '300px';
                domElements.sideToolbarToggle.style.left = '280px';
            }

            // Only scale image if it exists
            const img = domElements.imageContainer.querySelector('img');
            if (img) {
                core.scaleImage();
                core.displayBoxes();
            }

            ui.recalculateImageListLayout();

            // Re-enable transitions after a short delay
            setTimeout(() => {
                boxes.forEach(box => {
                    box.style.transition = '';
                });
            }, 50); // Adjust delay as needed
        });
    },

    // Update visibility of UI elements
    updateUIVisibility: () => {
        const elementsToToggle = [
            domElements.toolbar,
            domElements.contextMenu,
            domElements.sideToolbarWrapper,
            domElements.toolbarIcon,
            domElements.helpIcon
        ];

        elementsToToggle.forEach(element => {
            if (element) {
                element.style.display = constants.showUIElements ? '' : 'none';
            }
        });

        if (!constants.showUIElements) {
            domElements.sideToolbarToggle.style.display = 'none';
            domElements.imageContainer.style.marginLeft = '0';
        } else {
            domElements.sideToolbarToggle.style.display = '';
            ui.handleResize();
        }

        const boxes = document.querySelectorAll('.box');
        boxes.forEach(box => {
            if (constants.showUIElements) {
                box.style.border = '';
                box.style.backgroundColor = '';
                box.querySelector('.box-indicators').classList.remove('hide-indicators');
                box.querySelector('.box-indicators').classList.add('show-indicators');
            } else {
                box.style.border = 'none';
                box.style.backgroundColor = 'transparent';
                box.querySelector('.box-indicators').classList.remove('show-indicators');
                box.querySelector('.box-indicators').classList.add('hide-indicators');
            }
        });
    },

    showContextMenu: (e, box) => {
        e.preventDefault();



        const menuItems = {
            moveBox: { id: 'moveBox', icon: 'fa-arrows-alt', title: 'Move this box', color: '#4CAF50' },
            copyBox: { id: 'copyBox', icon: 'fa-copy', title: 'Copy this box', color: '#3498db' },
            resizeBox: { id: 'resizeBox', icon: 'fa-expand', title: 'Resize this box', color: '#2196F3' },
            linkBox: { id: 'linkBox', icon: 'fa-link', title: 'Link this box to image', color: '#FF9800' },
            unlinkBox: { id: 'unlinkBox', icon: 'fa-unlink', title: 'Remove link from box', color: '#FF5722' },
            toggleGlobalBox: { id: 'toggleGlobalBox', icon: 'fa-globe', title: 'Toggle global visibility for this box', color: '#9C27B0' },
            editVisibility: { id: 'editVisibility', icon: 'fa-list-ul', title: 'Edit visibility of this global box on all images', color: '#00BCD4' },
            hideUnhideGlobal: { id: 'hideUnhideGlobal', icon: 'fa-eye-slash', title: 'Hide this global box on current image', color: '#795548' },
            deleteBox: { id: 'deleteBox', icon: 'fa-trash-alt', title: 'Delete this box', color: '#F44336' }
        };


         // NEW: If the element is a textbox, remove link/unlink options from the context menu.
        if (box.classList.contains('textbox')) {
            delete menuItems.linkBox;
            delete menuItems.unlinkBox;
            delete menuItems.copyBox;
            delete menuItems.toggleGlobalBox;
            delete menuItems.editVisibility;
            delete menuItems.hideUnhideGlobal;
        }
        
        const isGlobal = box.classList.contains('global');

        let menuContent = '';
        let globalOptionsContent = '';

        Object.entries(menuItems).forEach(([key, item]) => {
            if (key === 'toggleGlobalBox' || (isGlobal && (key === 'editVisibility' || key === 'hideUnhideGlobal'))) {
                globalOptionsContent += `<li id="${item.id}" class="global-option ${isGlobal && key === 'toggleGlobalBox' ? 'active' : ''}" title="${item.title}" data-color="${item.color}"><i class="fas ${item.icon}"></i></li>`;
            } else {
                menuContent += `<li id="${item.id}" title="${item.title}" data-color="${item.color}"><i class="fas ${item.icon}"></i></li>`;
            }
        });

        if (globalOptionsContent) {
            menuContent += `<div class="global-options-container">${globalOptionsContent}</div>`;
        }

        domElements.contextMenu.querySelector('ul').innerHTML = menuContent;

        domElements.contextMenu.querySelectorAll('li').forEach(li => li.classList.remove('hover'));

        // Add event listeners for menu items if the corresponding element exists
        const moveEl = document.getElementById('moveBox');
        if (moveEl) moveEl.onclick = () => ui.startMovingBox(box);

        const copyEl = document.getElementById('copyBox');
        if (copyEl) copyEl.onclick = () => ui.copyBox(box);

        const resizeEl = document.getElementById('resizeBox');
        if (resizeEl) resizeEl.onclick = () => ui.startResizingBox(box);

        const linkEl = document.getElementById('linkBox');
        if (linkEl) linkEl.onclick = () => ui.linkBox(box);

        const unlinkEl = document.getElementById('unlinkBox');
        if (unlinkEl) unlinkEl.onclick = () => ui.unlinkBox(box);

        const deleteEl = document.getElementById('deleteBox');
        if (deleteEl) deleteEl.onclick = () => ui.deleteBox(box);

        const toggleGlobalEl = document.getElementById('toggleGlobalBox');
        if (toggleGlobalEl) {
            toggleGlobalEl.onclick = () => {
                toggleGlobalEl.classList.toggle('active');
                core.toggleGlobalBox(box);
            };
        }

        const editVisibilityBtn = document.getElementById('editVisibility');
        const hideUnhideGlobalBtn = document.getElementById('hideUnhideGlobal');

        if (editVisibilityBtn) {
            editVisibilityBtn.onclick = () => ui.editGlobalBoxVisibility(box);
            editVisibilityBtn.style.display = isGlobal ? 'inline-block' : 'none';
        }

        if (hideUnhideGlobalBtn) {
            hideUnhideGlobalBtn.onclick = () => ui.hideUnhideGlobalBox(box);
            hideUnhideGlobalBtn.style.display = isGlobal ? 'inline-block' : 'none';
        }

        const linkBoxEl = document.getElementById('linkBox');
        const unlinkBoxEl = document.getElementById('unlinkBox');
        if (linkBoxEl) {
            linkBoxEl.style.display = box.classList.contains('linked') ? 'none' : 'inline-block';
        }
        if (unlinkBoxEl) {
            unlinkBoxEl.style.display = box.classList.contains('linked') ? 'inline-block' : 'none';
        }

        // Show or hide the border for global options
        const globalOptionsContainer = domElements.contextMenu.querySelector('.global-options-container');
        if (globalOptionsContainer) {
            globalOptionsContainer.style.boxShadow = isGlobal ? '0px 0px 0px .6px #FFF, inset 0px 0px 9px 5px #6c3391' : 'none';
        }

        domElements.contextMenu.addEventListener('mousemove', ui.handleContextMenuHover);

        
        const linkMessageOverlay = document.querySelector('.link-message-overlay');
        if (linkMessageOverlay) {
            linkMessageOverlay.style.opacity = '0';
        }

        domElements.contextMenu.addEventListener('mouseleave', () => {
            domElements.contextMenu.querySelectorAll('li').forEach(li => li.classList.remove('hover'));
        });

       // Position the context menu
       const contextMenu = domElements.contextMenu;
       contextMenu.classList.remove('hidden', 'vertical');
   
       // Set initial position to make the menu visible
       contextMenu.style.left = '0px';
       contextMenu.style.top = '0px';
       
       // Get the dimensions of the context menu and the move button
       const menuRect = contextMenu.getBoundingClientRect();
       const moveButton = document.getElementById('moveBox');
       const moveButtonRect = moveButton.getBoundingClientRect();
       
       // Calculate available space
       const viewportWidth = window.innerWidth;
       const viewportHeight = window.innerHeight;
       
       let left, top;

       // Buffer space (adjust as needed)
       const buffer = -20;
   
       // Check if there's enough space to the right
       const spaceToRight = viewportWidth - e.clientX;
       if (spaceToRight < menuRect.width + buffer) {
           // Not enough space, switch to vertical layout
           contextMenu.classList.add('vertical');
           
           // Recalculate menu dimensions after switching to vertical
           const verticalMenuRect = contextMenu.getBoundingClientRect();
           
           // Position the menu with "Move Box" centered over the cursor
           left = e.clientX - moveButtonRect.width / 2;
           top = e.clientY - moveButtonRect.height / 2;
           
           // Adjust if it goes off the right edge
           if (left + verticalMenuRect.width > viewportWidth) {
               left = viewportWidth - verticalMenuRect.width;
           }
           
           // Adjust if it goes off the bottom
           if (top + verticalMenuRect.height > viewportHeight) {
               top = viewportHeight - verticalMenuRect.height;
           }
       } else {
           // Enough space for horizontal layout
           // Calculate the position to center the move button on the cursor
           left = e.clientX - (moveButtonRect.left - menuRect.left) - moveButtonRect.width / 2;
           top = e.clientY - (moveButtonRect.top - menuRect.top) - moveButtonRect.height / 2;
           
           // Check if it would be cut off on the right
           if (left + menuRect.width > viewportWidth - buffer) {
               // Try to adjust horizontally first
               left = viewportWidth - menuRect.width - buffer;
               
               // If still not enough space, switch to vertical layout
               if (left < 0) {
                   contextMenu.classList.add('vertical');
                   const verticalMenuRect = contextMenu.getBoundingClientRect();
                   
                   left = e.clientX - moveButtonRect.width / 2;
                   // Adjust if it goes off the right edge
                   if (left + verticalMenuRect.width > viewportWidth) {
                       left = viewportWidth - verticalMenuRect.width;
                   }
               }
           }
       }
       
       // Ensure the menu doesn't go above the top of the viewport
       if (top < 0) {
           top = 0;
       }
       
       // Set the position of the context menu
       contextMenu.style.left = `${left}px`;
       contextMenu.style.top = `${top}px`;
   
       // After setting the position, check if vertical layout is cut off at the bottom and switch back to horizontal if necessary
       const finalMenuRect = contextMenu.getBoundingClientRect();
       if (contextMenu.classList.contains('vertical') && finalMenuRect.bottom > viewportHeight) {
           contextMenu.classList.remove('vertical');
           // Recalculate position for horizontal layout
           left = e.clientX - (moveButtonRect.left - menuRect.left) - moveButtonRect.width / 2;
           top = e.clientY - (moveButtonRect.top - menuRect.top) - moveButtonRect.height / 2;
           
           // Adjust if it goes off the right edge
           if (left + menuRect.width > viewportWidth) {
               left = viewportWidth - menuRect.width;
           }
           
           // Adjust if it goes off the bottom
           if (top + menuRect.height > viewportHeight) {
               top = viewportHeight - menuRect.height;
           }
           
           contextMenu.style.left = `${left}px`;
           contextMenu.style.top = `${top}px`;
       }
   },




    // Handle hover effects in the context menu
    handleContextMenuHover: (e) => {
        const menuRect = domElements.contextMenu.getBoundingClientRect();
        const mouseX = e.clientX - menuRect.left;
        const mouseY = e.clientY - menuRect.top;

        domElements.contextMenu.querySelectorAll('li').forEach(li => {
            const liRect = li.getBoundingClientRect();
            const relativeRect = {
                left: liRect.left - menuRect.left,
                top: liRect.top - menuRect.top,
                right: liRect.right - menuRect.left,
                bottom: liRect.bottom - menuRect.top
            };

            if (mouseX >= relativeRect.left && mouseX <= relativeRect.right &&
                mouseY >= relativeRect.top && mouseY <= relativeRect.bottom) {
                li.classList.add('hover');
            } else {
                li.classList.remove('hover');
            }
        });
    },

    // Start moving a box
    startMovingBox: (box) => {
        constants.isMoving = true;
        constants.movingBox = box;
        // Store original position for cancellation
        constants.originalBoxPosition = { left: box.style.left, top: box.style.top };
        box.classList.add('moving');
        domElements.contextMenu.classList.add('hidden');

        // Get the current mouse position
        const initialMouseX = event.clientX;
        const initialMouseY = event.clientY;

        // Get the image container's position
        const containerRect = domElements.imageContainer.getBoundingClientRect();

        // Get the box dimensions
        const boxRect = box.getBoundingClientRect();
        const boxWidth = boxRect.width;
        const boxHeight = boxRect.height;

        // Calculate the new position to center the box on the cursor
        const newLeft = initialMouseX - containerRect.left - boxWidth / 2;
        const newTop = initialMouseY - containerRect.top - boxHeight / 2;

        // Set the new position
        box.style.left = `${newLeft}px`;
        box.style.top = `${newTop}px`;

        let isSnappedX = false;
        let isSnappedY = false;
        let snappedX = null;
        let snappedY = null;

        function moveHandler(e) {
            if (constants.isMoving) {
                const currentLeft = e.clientX - containerRect.left - boxWidth / 2;
                const currentTop = e.clientY - containerRect.top - boxHeight / 2;

                const allBoxes = Array.from(domElements.imageContainer.querySelectorAll('.box'));

                const { snapX, snapY, snapped } = core.calculateSnapPosition(constants.movingBox, allBoxes, { x: currentLeft, y: currentTop });

                // Handle horizontal snapping
                if (snapX !== null && !isSnappedX) {
                    isSnappedX = true;
                    snappedX = snapX;
                } else if (isSnappedX && Math.abs(currentLeft - snappedX) > constants.snapStickiness) {
                    isSnappedX = false;
                }

                // Handle vertical snapping
                if (snapY !== null && !isSnappedY) {
                    isSnappedY = true;
                    snappedY = snapY;
                } else if (isSnappedY && Math.abs(currentTop - snappedY) > constants.snapStickiness) {
                    isSnappedY = false;
                }

                let finalLeft = isSnappedX ? snappedX : currentLeft;
                let finalTop = isSnappedY ? snappedY : currentTop;

                constants.movingBox.style.left = `${finalLeft}px`;
                constants.movingBox.style.top = `${finalTop}px`;
            }
        }

        function stopMoving(e) {
            if (constants.isMoving && e.button === 0) {
                domElements.contextMenu.classList.add('hidden');

                constants.isMoving = false;
                constants.movingBox.classList.remove('moving');

                const img = domElements.imageContainer.querySelector('img');
                const imgRect = img.getBoundingClientRect();
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;

                const newX = (parseFloat(constants.movingBox.style.left) - offsetX) / imgRect.width;
                const newY = (parseFloat(constants.movingBox.style.top) - offsetY) / imgRect.height;

                const isGlobal = constants.movingBox.classList.contains('global');
                let boxData;
                if (constants.movingBox.classList.contains('textbox')) {
                    boxData = isGlobal
                      ? constants.globalTextBoxes.find(b =>
                            parseFloat(b.x).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-x')).toFixed(4) &&
                            parseFloat(b.y).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-y')).toFixed(4)
                        )
                      : constants.textBoxes.find(b =>
                            b.screenshotIndex === constants.currentScreenshotIndex &&
                            parseFloat(b.x).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-x')).toFixed(4) &&
                            parseFloat(b.y).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-y')).toFixed(4)
                        );
                } else {
                    boxData = isGlobal 
                      ? constants.globalBoxes.find(b =>
                            parseFloat(b.x).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-x')).toFixed(4) &&
                            parseFloat(b.y).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-y')).toFixed(4)
                        )
                      : constants.boxes.find(b =>
                            b.screenshotIndex === constants.currentScreenshotIndex &&
                            parseFloat(b.x).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-x')).toFixed(4) &&
                            parseFloat(b.y).toFixed(4) === parseFloat(constants.movingBox.getAttribute('data-y')).toFixed(4)
                        );
                }

                if (boxData) {
                    boxData.x = newX;
                    boxData.y = newY;
                    constants.movingBox.setAttribute('data-x', newX);
                    constants.movingBox.setAttribute('data-y', newY);
                }

                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', stopMoving);
                constants.currentMoveHandlers = null;

                constants.lastMoveTime = Date.now();

                e.preventDefault();
                e.stopPropagation();

                ui.hideModeIndicator();

                // Reset copy mode flag (if applicable)
                if (constants.isCopyMode) {
                    constants.isCopyMode = false;
                }
            }
        }

        // Save the event handlers for cancellation later
        constants.currentMoveHandlers = { moveHandler, stopMoving };

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', stopMoving);

        ui.showModeIndicator('Move Box Mode', 'fa-arrows-alt');
    },

    // Add a new copyBox function to the ui object
    copyBox: (box) => {
        const isGlobal = box.classList.contains('global');
        const originalBoxData = isGlobal
            ? constants.globalBoxes.find(b => 
                  b.x === parseFloat(box.getAttribute('data-x')) && 
                  b.y === parseFloat(box.getAttribute('data-y'))
              )
            : constants.boxes.find(b => 
                  b.screenshotIndex === constants.currentScreenshotIndex && 
                  b.x === parseFloat(box.getAttribute('data-x')) && 
                  b.y === parseFloat(box.getAttribute('data-y'))
              );

        if (originalBoxData) {
            const img = domElements.imageContainer.querySelector('img');
            const imgRect = img.getBoundingClientRect();
            const containerRect = domElements.imageContainer.getBoundingClientRect();

            const cursorX = (event.clientX - imgRect.left) / imgRect.width;
            const cursorY = (event.clientY - imgRect.top) / imgRect.height;

            const newBox = {
                x: cursorX - (originalBoxData.width / 2),
                y: cursorY - (originalBoxData.height / 2),
                width: originalBoxData.width,
                height: originalBoxData.height,
                linkedTo: null,
                screenshotIndex: constants.currentScreenshotIndex
            };

            if (isGlobal) {
                newBox.visibleOn = [constants.currentScreenshotIndex];
                constants.globalBoxes.push(newBox);
            } else {
                constants.boxes.push(newBox);
            }

            domElements.contextMenu.classList.add('hidden');

            core.displayBoxes();

            // Mark that we are in copy mode so Esc will remove the new box
            constants.isCopyMode = true;

            const newBoxElement = domElements.imageContainer.querySelector(`.box[data-x="${newBox.x}"][data-y="${newBox.y}"]`);

            if (newBoxElement) {
                ui.startMovingBox(newBoxElement);
            }
        }
        core.updateBoxCounts();
    },

    // Start resizing a box
    startResizingBox: (box) => {
        // Set resizing state and update UI
        constants.isResizing = true;
        constants.resizingBox = box;
        // Store original dimensions for cancellation
        constants.originalBoxDimensions = { width: box.style.width, height: box.style.height };
        box.classList.add('resizing');
        domElements.contextMenu.classList.add('hidden');

        // Create and add resize handle to the box
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        resizeHandle.style.position = 'absolute';
        resizeHandle.style.right = '0';
        resizeHandle.style.bottom = '0';
        resizeHandle.style.width = '10px';
        resizeHandle.style.height = '10px';
        resizeHandle.style.cursor = 'se-resize';
        resizeHandle.style.backgroundColor = 'white';
        resizeHandle.style.border = '1px solid black';
        box.appendChild(resizeHandle);

        const boxRect = box.getBoundingClientRect();
        const cornerX = boxRect.right;
        const cornerY = boxRect.bottom;
        const initialBoxWidth = boxRect.width;
        const initialBoxHeight = boxRect.height;

        function resizeHandler(e) {
            if (constants.isResizing) {
                let dx = e.clientX - cornerX;
                let dy = e.clientY - cornerY;

                let newWidth = Math.max(10, initialBoxWidth + dx);
                let newHeight = Math.max(10, initialBoxHeight + dy);

                // Track if we're currently snapped
                let isSnappedWidth = false;
                let isSnappedHeight = false;
                let snappedWidth = null;
                let snappedHeight = null;

                const resizingBoxRect = constants.resizingBox.getBoundingClientRect();
                const resizingBoxLeft = resizingBoxRect.left;
                const resizingBoxTop = resizingBoxRect.top;
                const resizingRight = resizingBoxLeft + newWidth;
                const resizingBottom = resizingBoxTop + newHeight;

                const allBoxes = Array.from(document.querySelectorAll('.box:not(.resizing), .textbox:not(.resizing)'));

                allBoxes.forEach(otherBox => {
                    const otherRect = otherBox.getBoundingClientRect();
                    
                    // Check if we're already snapped and if the current size is far enough from snapped size
                    if (snappedWidth !== null) {
                        const currentSnapDelta = Math.abs(newWidth - snappedWidth);
                        if (currentSnapDelta > constants.snapStickiness) {
                            isSnappedWidth = false;
                            snappedWidth = null;
                        }
                    }

                    if (snappedHeight !== null) {
                        const currentSnapDelta = Math.abs(newHeight - snappedHeight);
                        if (currentSnapDelta > constants.snapStickiness) {
                            isSnappedHeight = false;
                            snappedHeight = null;
                        }
                    }

                    // Edge snapping calculations
                    const rightEdgeSnap = Math.abs(resizingRight - otherRect.left) < constants.snapThreshold;
                    const leftEdgeSnap = Math.abs(resizingRight - otherRect.right) < constants.snapThreshold;
                    const bottomEdgeSnap = Math.abs(resizingBottom - otherRect.top) < constants.snapThreshold;
                    const topEdgeSnap = Math.abs(resizingBottom - otherRect.bottom) < constants.snapThreshold;

                    // If we snap to an edge, calculate the new width/height based on the edge position
                    if (!isSnappedWidth && (rightEdgeSnap || leftEdgeSnap)) {
                        const newSnappedWidth = rightEdgeSnap ? 
                            otherRect.left - resizingBoxLeft : 
                            otherRect.right - resizingBoxLeft;
                        
                        if (newSnappedWidth >= 10) { // Ensure minimum width
                            snappedWidth = newSnappedWidth;
                            isSnappedWidth = true;
                        }
                    }

                    if (!isSnappedHeight && (bottomEdgeSnap || topEdgeSnap)) {
                        const newSnappedHeight = bottomEdgeSnap ? 
                            otherRect.top - resizingBoxTop : 
                            otherRect.bottom - resizingBoxTop;
                        
                        if (newSnappedHeight >= 10) { // Ensure minimum height
                            snappedHeight = newSnappedHeight;
                            isSnappedHeight = true;
                        }
                    }

                    // Size matching snapping (existing logic)
                    if (!isSnappedWidth && Math.abs(newWidth - otherRect.width) < constants.snapThreshold) {
                        snappedWidth = otherRect.width;
                        isSnappedWidth = true;
                    }
                    
                    if (!isSnappedHeight && Math.abs(newHeight - otherRect.height) < constants.snapThreshold) {
                        snappedHeight = otherRect.height;
                        isSnappedHeight = true;
                    }
                });

                // Apply snapped dimensions if they exist
                if (isSnappedWidth && snappedWidth !== null) {
                    newWidth = snappedWidth;
                }
                if (isSnappedHeight && snappedHeight !== null) {
                    newHeight = snappedHeight;
                }

                constants.resizingBox.style.width = `${newWidth}px`;
                constants.resizingBox.style.height = `${newHeight}px`;
            }
        }

        function stopResizing(e) {
            if (constants.isResizing && e.button === 0) {
                domElements.contextMenu.classList.add('hidden');

                // Update the underlying box data with the new dimensions
                const img = domElements.imageContainer.querySelector('img');
                if (img) {
                    const imgRect = img.getBoundingClientRect();
                    const newPixelWidth = parseFloat(box.style.width);
                    const newPixelHeight = parseFloat(box.style.height);
                    const newNormWidth = newPixelWidth / imgRect.width;
                    const newNormHeight = newPixelHeight / imgRect.height;
 
                    const isGlobal = box.classList.contains('global');
                    let boxData;
                    
                    // NEW: Handle textbox resizing
                    if (box.classList.contains('textbox')) {
                        if (isGlobal) {
                            boxData = constants.globalTextBoxes.find(b =>
                                parseFloat(b.x).toFixed(4) === parseFloat(box.getAttribute('data-x')).toFixed(4) &&
                                parseFloat(b.y).toFixed(4) === parseFloat(box.getAttribute('data-y')).toFixed(4)
                            );
                        } else {
                            boxData = constants.textBoxes.find(b =>
                                b.screenshotIndex === constants.currentScreenshotIndex &&
                                parseFloat(b.x).toFixed(4) === parseFloat(box.getAttribute('data-x')).toFixed(4) &&
                                parseFloat(b.y).toFixed(4) === parseFloat(box.getAttribute('data-y')).toFixed(4)
                            );
                        }
                    } else {
                        // Existing code for regular boxes
                        if (isGlobal) {
                            boxData = constants.globalBoxes.find(b =>
                                parseFloat(b.x).toFixed(4) === parseFloat(box.getAttribute('data-x')).toFixed(4) &&
                                parseFloat(b.y).toFixed(4) === parseFloat(box.getAttribute('data-y')).toFixed(4)
                            );
                        } else {
                            boxData = constants.boxes.find(b =>
                                b.screenshotIndex === constants.currentScreenshotIndex &&
                                parseFloat(b.x).toFixed(4) === parseFloat(box.getAttribute('data-x')).toFixed(4) &&
                                parseFloat(b.y).toFixed(4) === parseFloat(box.getAttribute('data-y')).toFixed(4)
                            );
                        }
                    }

                    if (boxData) {
                        boxData.width = newNormWidth;
                        boxData.height = newNormHeight;
                    }
                    box.setAttribute('data-width', newNormWidth);
                    box.setAttribute('data-height', newNormHeight);
                }
 
                document.removeEventListener('mousemove', resizeHandler);
                document.removeEventListener('mouseup', stopResizing);
                constants.currentResizeHandlers = null;
 
                constants.isResizing = false;
                const handle = box.querySelector('.resize-handle');
                if (handle) {
                    handle.remove();
                }
                box.classList.remove('resizing');
                ui.hideModeIndicator();
 
                e.preventDefault();
                e.stopPropagation();

                // NEW: Resize text content after resizing the box
                if (box.classList.contains('textbox')) {
                    core.resizeTextBoxContent(box);
                }
            }
        }

        // Save resize event handlers for potential cancellation
        constants.currentResizeHandlers = { resizeHandler, stopResizing };

        document.addEventListener('mousemove', resizeHandler);
        document.addEventListener('mouseup', stopResizing);

        ui.showModeIndicator('Resize Box Mode', 'fa-expand');
    },

    // Link a box to another image
    linkBox: (box) => {
        console.log('Entering linkBox function');
        document.body.classList.add('link-mode-cursor');
        domElements.imageContainer.classList.add('link-mode-cursor');
        domElements.contextMenu.classList.add('hidden');
        domElements.imageList.classList.add('linking');

        // Set link mode flag
        constants.isLinkMode = true;

        // Remove any existing link message overlay
        const existingMessage = document.querySelector('.link-message-overlay');
        if (existingMessage) {
            existingMessage.remove();
        }

        const message = document.createElement('div');
        message.innerHTML = 'Click on <i class="fas fa-image"></i> to link';
        message.className = 'link-message-overlay';
        domElements.sideToolbarWrapper.appendChild(message);

        ui.showModeIndicator('Link Box Mode', 'fa-link', true);

        // Define the link handler function
        const linkHandler = (e) => {
            console.log('Link handler triggered');
            const imageItem = e.target.closest('.image-item');
            if (imageItem) {
                console.log('Image item clicked for linking');
                e.preventDefault();
                e.stopPropagation();

                const linkedToIndex = Array.from(domElements.imageList.children).indexOf(imageItem);
                console.log(`Linking to index: ${linkedToIndex}`);
                
                const isGlobal = box.classList.contains('global');
                let boxData = isGlobal 
                    ? constants.globalBoxes.find(b => 
                          b.x === parseFloat(box.getAttribute('data-x')) &&
                          b.y === parseFloat(box.getAttribute('data-y'))
                      )
                    : constants.boxes.find(b => 
                          b.screenshotIndex === constants.currentScreenshotIndex &&
                          b.x === parseFloat(box.getAttribute('data-x')) &&
                          b.y === parseFloat(box.getAttribute('data-y'))
                      );
                
                if (boxData) {
                    boxData.linkedTo = linkedToIndex;
                    box.classList.add('linked');
                    box.setAttribute('data-linked-to', linkedToIndex);
                    console.log(`Box linked successfully. Now linked to image at index ${linkedToIndex} - ${constants.screenshots[linkedToIndex]?.name}`);
                    core.updateBoxCounts();
                    imageItem.classList.add('linked-highlight');
                    setTimeout(() => {
                        imageItem.classList.remove('linked-highlight');
                    }, 800);
                }

                domElements.imageList.classList.remove('linking');
                message.remove();
                domElements.imageList.removeEventListener('click', linkHandler);
                domElements.sideToolbarWrapper.removeEventListener('mouseover', hideMessage);
                domElements.sideToolbarWrapper.removeEventListener('mouseout', showMessage);
                core.displayBoxes();

                ui.hideModeIndicator();
                domElements.contextMenu.classList.add('hidden');

                // Reset link mode
                constants.isLinkMode = false;
                constants.currentLinkHandler = null;
                document.body.classList.remove('link-mode-cursor');
                domElements.imageContainer.classList.remove('link-mode-cursor');
            }
        };

        // Store the link handler for cancellation purposes
        constants.currentLinkHandler = linkHandler;

        const hideMessage = () => {
            message.style.opacity = '0';
        };

        const showMessage = () => {
            message.style.opacity = '1';
        };

        console.log('Adding link handler');
        domElements.imageList.addEventListener('click', linkHandler);
        domElements.sideToolbarWrapper.addEventListener('mouseover', hideMessage);
        domElements.sideToolbarWrapper.addEventListener('mouseout', showMessage);

        // ... (rest of your linkBox code, including context menu positioning if any)
    },

    // Unlink a box
    unlinkBox: (box) => {
        const isGlobal = box.classList.contains('global');
        let boxData = isGlobal
            ? constants.globalBoxes.find(b => b.x === parseFloat(box.getAttribute('data-x')) && b.y === parseFloat(box.getAttribute('data-y')))
            : constants.boxes.find(b => b.screenshotIndex === constants.currentScreenshotIndex && b.x === parseFloat(box.getAttribute('data-x')) && b.y === parseFloat(box.getAttribute('data-y')));

        if (boxData) {
            boxData.linkedTo = null;
            box.classList.remove('linked');
            box.removeAttribute('data-linked-to');
        }

        domElements.contextMenu.classList.add('hidden');
        core.displayBoxes();
        core.updateBoxCounts();
    },

    // Delete a box
    deleteBox: (box) => {
        // NEW: If the element is a textbox, remove it from the correct array.
        if (box.classList.contains('textbox')) {
            if (box.classList.contains('global')) {
                // Find and remove from globalTextBoxes
                const idx = constants.globalTextBoxes.findIndex(tb =>
                    tb.x === parseFloat(box.getAttribute('data-x')) &&
                    tb.y === parseFloat(box.getAttribute('data-y')) &&
                    tb.width === parseFloat(box.getAttribute('data-width')) &&
                    tb.height === parseFloat(box.getAttribute('data-height'))
                );
                if (idx > -1) {
                    constants.globalTextBoxes.splice(idx, 1);
                }
            } else {
                // Find and remove from local textBoxes
                const idx = constants.textBoxes.findIndex(tb =>
                    tb.x === parseFloat(box.getAttribute('data-x')) &&
                    tb.y === parseFloat(box.getAttribute('data-y')) &&
                    tb.width === parseFloat(box.getAttribute('data-width')) &&
                    tb.height === parseFloat(box.getAttribute('data-height'))
                );
                if (idx > -1) {
                    constants.textBoxes.splice(idx, 1);
                }
            }
            box.remove();
            core.displayBoxes();
            core.updateBoxCounts();
            return; // Exit after handling a textbox element.
        }
        
        // Existing deletion logic for normal boxes
        const isGlobal = box.classList.contains('global');
        if (isGlobal) {
            const globalBoxIndex = constants.globalBoxes.findIndex(b =>
                b.x === parseFloat(box.getAttribute('data-x')) &&
                b.y === parseFloat(box.getAttribute('data-y'))
            );
            if (globalBoxIndex > -1) {
                constants.globalBoxes.splice(globalBoxIndex, 1);
            }
        } else {
            const boxData = constants.boxes.find(b =>
                b.screenshotIndex === constants.currentScreenshotIndex &&
                b.x === parseFloat(box.getAttribute('data-x')) &&
                b.y === parseFloat(box.getAttribute('data-y'))
            );
            if (boxData) {
                const index = constants.boxes.indexOf(boxData);
                if (index > -1) {
                    constants.boxes.splice(index, 1);
                }
            }
        }
        
        box.remove();
        core.displayBoxes();
        core.updateBoxCounts();
    },

// Edit visibility of a global box
editGlobalBoxVisibility: (box) => {
    // Find the global box data based on its coordinates
    const globalBox = constants.globalBoxes.find(b => 
        b.x === parseFloat(box.getAttribute('data-x')) && 
        b.y === parseFloat(box.getAttribute('data-y'))
    );

    if (globalBox) {
        // Create modal overlay
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';

        // Create visibility menu with loading state
        const visibilityMenu = document.createElement('div');
        visibilityMenu.id = 'visibilityMenu';
        visibilityMenu.className = 'visibility-modal';
        visibilityMenu.innerHTML = `
            <div class="visibility-header">
                <h3>Edit Global Box Visibility</h3>
                <p>Select images to show this box on:</p>
                <div class="visibility-controls">
                    <button id="selectAll">Select All</button>
                    <button id="deselectAll">Deselect All</button>
                    <select id="tagFilter">
                        <option value="">All Tags</option>
                        ${Array.from(new Set(constants.screenshots.flatMap(s => s.tags))).map(tag => 
                            `<option value="${tag}">${tag}</option>`
                        ).join('')}
                    </select>
                </div>
            </div>
            <div class="checkbox-list-container">
                <div class="checkbox-list">
                    <div class="loading-indicator">Loading images...</div>
                </div>
            </div>
        `;

        // Add modal to DOM immediately to show loading state
        modalOverlay.appendChild(visibilityMenu);
        document.body.appendChild(modalOverlay);

        const checkboxList = visibilityMenu.querySelector('.checkbox-list');

        // Function to create checkboxes with virtualization
        const createCheckboxes = (filter = '') => {
            console.log('Creating checkboxes with filter:', filter);
            const batchSize = 20; // Number of items to render in each batch
            const filteredScreenshots = constants.screenshots.filter(screenshot =>
                filter === '' || screenshot.tags.includes(filter)
            );
            console.log('Filtered screenshots:', filteredScreenshots);

            let currentBatch = 0;
            checkboxList.innerHTML = ''; // Clear existing checkboxes

            // Create and append a container for virtual scrolling
            const virtualContainer = document.createElement('div');
            virtualContainer.className = 'virtual-container'; // Add class for styling
            virtualContainer.style.minHeight = `${Math.ceil(filteredScreenshots.length / 3) * 50}px`; // Adjust for grid, potentially incorrect if images per row changes
            checkboxList.appendChild(virtualContainer);
            console.log('Virtual container created:', virtualContainer, 'Initial minHeight:', virtualContainer.style.minHeight);

            function renderBatch() {
                console.log('Rendering batch:', currentBatch);
                const fragment = document.createDocumentFragment();
                const start = currentBatch * batchSize;
                const end = Math.min(start + batchSize, filteredScreenshots.length);

                if (start >= filteredScreenshots.length) {
                    console.log('No more batches to render.');
                    return false;
                }

                for (let i = start; i < end; i++) {
                    const screenshot = filteredScreenshots[i];
                    const index = constants.screenshots.indexOf(screenshot);

                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = 'checkbox-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `visibility-${index}`;
                    checkbox.checked = globalBox.visibleOn.includes(index);

                    checkbox.addEventListener('change', () => {
                        console.log('Checkbox changed for index:', index, 'checked:', checkbox.checked);
                        if (checkbox.checked) {
                            if (!globalBox.visibleOn.includes(index)) {
                                globalBox.visibleOn.push(index);
                                console.log('Added index to visibleOn:', index, globalBox.visibleOn);
                            }
                        } else {
                            globalBox.visibleOn = globalBox.visibleOn.filter(i => i !== index);
                            console.log('Removed index from visibleOn:', index, globalBox.visibleOn);
                        }
                        core.displayBoxes();
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `visibility-${index}`;

                    const img = new Image();
                    img.src = screenshot.data;
                    img.style.width = '40px';
                    img.style.height = '40px';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '4px';
                    img.alt = screenshot.name;
                    // Add error handling for image loading
                    img.onerror = () => {
                        console.error('Error loading image:', screenshot.name, screenshot.data);
                        img.src = 'path/to/placeholder/image.png'; // Replace with a placeholder
                    };

                    const span = document.createElement('span');
                    span.title = screenshot.name;
                    span.textContent = screenshot.name;
                    span.style.overflow = 'hidden';
                    span.style.textOverflow = 'ellipsis';
                    span.style.whiteSpace = 'nowrap';
                    span.style.flex = '1';

                    label.appendChild(img);
                    label.appendChild(span);
                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(label);
                    fragment.appendChild(checkboxItem);
                }

                virtualContainer.appendChild(fragment);
                currentBatch++;
                console.log('Batch rendered and appended. Items in this batch:', end - start);
                return true;
            }

            // Initial render
            renderBatch();

            // Set up intersection observer for infinite scrolling
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    console.log('Intersection observer entry:', entry);
                    if (entry.isIntersecting) {
                        console.log("Observed element is intersecting");
                         if (!renderBatch())
                         {
                            observer.disconnect();
                            console.log('Observer disconnected.');
                         }

                    }
                });
            }, {
                root: checkboxList, // Use the checkbox list as the viewport
                threshold: 0.1,  // Trigger when 10% of the target is visible
                rootMargin: '100px' // Load more items before reaching the end
            });

            // Observe the last item *after* the initial render.  We need to find it *within* the virtualContainer
            const updateObserver = () => {
                const lastItem = virtualContainer.lastElementChild; // Check for the last item *within* the virtual container
                if (lastItem) {
                    console.log('Observing last item:', lastItem);
                    observer.observe(lastItem);
                } else {
                    console.log('No last item to observe yet.');
                }
            }
            updateObserver(); // Initial observation

            //Observe new items after each batch render
            const observerReseter = new MutationObserver(() => {
                console.log("Mutation detected, re-observing")
                updateObserver();
            });

            observerReseter.observe(virtualContainer, {childList: true});


        };

        // Create initial checkboxes after a short delay to allow modal to show
        requestAnimationFrame(() => {
            createCheckboxes();
        });

        // Add event listener for tag filter
        const tagFilter = visibilityMenu.querySelector('#tagFilter');
        tagFilter.addEventListener('change', (e) => {
            checkboxList.innerHTML = '<div class="loading-indicator">Loading images...</div>';
            requestAnimationFrame(() => {
                createCheckboxes(e.target.value);
            });
        });

        // Add event listeners for Select All/Deselect All
        document.getElementById('selectAll').addEventListener('click', () => {
            const visibleCheckboxes = checkboxList.querySelectorAll('input[type="checkbox"]:not([disabled])');
            visibleCheckboxes.forEach(cb => {
                if (!cb.checked) {
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        });

        document.getElementById('deselectAll').addEventListener('click', () => {
            const visibleCheckboxes = checkboxList.querySelectorAll('input[type="checkbox"]:not([disabled])');
            visibleCheckboxes.forEach(cb => {
                if (cb.checked) {
                    cb.checked = false;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        });

        // Close modal when clicking outside
        modalOverlay.addEventListener('mouseup', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }

    // Hide the context menu
    domElements.contextMenu.classList.add('hidden');
},


    // Hide or unhide a global box on the current image
    hideUnhideGlobalBox: (box) => {
        const globalBox = constants.globalBoxes.find(b => 
            b.x === parseFloat(box.getAttribute('data-x')) && 
            b.y === parseFloat(box.getAttribute('data-y'))
        );

        if (globalBox) {
            if (globalBox.visibleOn.includes(constants.currentScreenshotIndex)) {
                globalBox.visibleOn = globalBox.visibleOn.filter(i => i !== constants.currentScreenshotIndex);
            } else {
                globalBox.visibleOn.push(constants.currentScreenshotIndex);
            }
            core.displayBoxes();
        }

        domElements.contextMenu.classList.add('hidden');
    },

    // Set initial layout
    setInitialLayout: () => {
        if (constants.screenshots.length > 0) {
            core.scaleImage();
        } else {
            console.log('No screenshots available');
        }
    },

    // Recalculate image list layout
    recalculateImageListLayout: () => {
        // Only force layout if necessary
        const sideToolbar = domElements.sideToolbar;
        if (sideToolbar.offsetHeight === 0) {
            sideToolbar.offsetHeight; // Force layout
        }
        
        // Batch updates using requestAnimationFrame
        requestAnimationFrame(() => {
            ui.updateImageSize();
            sideToolbar.style.display = 'none';
            sideToolbar.offsetHeight; // Force layout
            sideToolbar.style.display = '';
        });
    },

    // Prevent dragging of the main image
    preventImageDrag: () => {
        const mainImage = domElements.imageContainer.querySelector('img');
        if (mainImage) {
            mainImage.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });
        }
    },

    // Update styles for boxes
    updateBoxStyles: () => {
        // Update CSS variables
        document.documentElement.style.setProperty('--local-box-color', constants.localBoxColor);
        document.documentElement.style.setProperty('--linked-box-color', constants.linkedBoxColor);
        document.documentElement.style.setProperty('--global-box-color', constants.globalBoxColor);
        document.documentElement.style.setProperty('--textbox-color', constants.textboxColor);

        const style = document.createElement('style');
        style.textContent = `
            .box {
                border-color: ${constants.localBoxColor};
                box-shadow: inset 0 0 11px ${constants.localBoxColor}, 0 0 11px ${constants.localBoxColor};
            }
            .box.linked {
                border-color: ${constants.linkedBoxColor};
                box-shadow: inset 0 0 11px ${constants.linkedBoxColor}, 0 0 11px ${constants.linkedBoxColor};
            }
            .box.global {
                border-color: ${constants.globalBoxColor};
                box-shadow: inset 0 0 11px ${constants.globalBoxColor}, 0 0 11px ${constants.globalBoxColor};
            }
            .textbox {
                border-color: ${constants.textboxColor};
                box-shadow: inset 0 0 11px ${constants.textboxColor}, 0 0 11px ${constants.textboxColor};
            }
            .indicator.linked-indicator {
                background-color: ${constants.linkedBoxColor}B3;
            }
            .indicator.global-indicator {
                background-color: ${constants.globalBoxColor}B3;
            }
            
            /* Box count colors */
            .local-count i {
                color: ${constants.localBoxColor};
            }
            .linked-count i {
                color: ${constants.linkedBoxColor};
            }
            .global-count i {
                color: ${constants.globalBoxColor};
            }
            .text-count i {
                color: ${constants.textboxColor};
            }
        `;

        const existingStyle = document.getElementById('boxStyles');
        if (existingStyle) {
            existingStyle.remove();
        }
        style.id = 'boxStyles';
        document.head.appendChild(style);

        // Force redraw of boxes to apply new styles
        core.displayBoxes();
    },

    // Update active image state in the sidebar
    updateActiveImageState: (activeIndex) => {
        const imageItems = domElements.imageList.querySelectorAll('.image-item');
        imageItems.forEach((item, i) => {
            item.classList.toggle('active', i === activeIndex);
        });
    },

    // Show mode indicator
    showModeIndicator: (mode, icon, persistent = false) => {
        if (!constants.modeIndicator) return;

        const iconElement = constants.modeIndicator.querySelector('i');
        const textElement = constants.modeIndicator.querySelector('span');

        iconElement.className = `fas ${icon}`;
        textElement.textContent = mode;

        constants.modeIndicator.classList.remove('hidden');

        // Clear any existing timeout
        clearTimeout(ui.modeIndicatorTimeout);

    },

    hideModeIndicator: () => {
        if (constants.modeIndicator) {
            constants.modeIndicator.classList.add('hidden');
        }
        clearTimeout(ui.modeIndicatorTimeout);
    },

    // Apply current filter to images
    applyCurrentFilter: () => {
        const searchTerm = document.getElementById('imageSearch').value.toLowerCase();
        const selectedTag = document.getElementById('tagFilter').value;

        ui.filterImages(searchTerm, selectedTag);
    },

    // Add loading styles
    addLoadingStyles: () => {
        const style = document.createElement('style');
        style.textContent = `
            .loading {
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100%;
                font-size: 24px;
                color: #888;
            }
        `;
        document.head.appendChild(style);
    },

    showTagManager: (index) => {
        console.log('showTagManager called for index:', index);
        const screenshot = constants.screenshots[index];
        
        // Create a Set to store unique recent tags
        const recentTags = new Set();

        // Populate recentTags with tags from all screenshots
        constants.screenshots.forEach(ss => {
            ss.tags.forEach(tag => recentTags.add(tag));
        });

        // Create modal element
        const modal = document.createElement('div');
        modal.className = 'tag-manager-modal modal';
        modal.innerHTML = `
            <div class="tag-manager-content modal-content" onclick="event.stopPropagation();">
                <h2>Manage Tags for ${screenshot.name}</h2>
                <div id="currentTags"></div>
                <input type="text" id="newTag" placeholder="Add new tag (press Enter to add)">
                <div id="recentTags">
                    <h3>Recent Tags</h3>
                    <div id="recentTagsList"></div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);

        // Get references to DOM elements
        const currentTags = modal.querySelector('#currentTags');
        const newTagInput = modal.querySelector('#newTag');
        const recentTagsContainer = modal.querySelector('#recentTagsList');

        // Debounce the expensive UI updates
        const debouncedUpdateImageList = utils.debounce(() => {
            core.updateImageList();
            ui.updateTagFilter();
        }, 300);

        // Function to update the display of current tags
        function updateTagDisplay() {
            requestAnimationFrame(() => {
                currentTags.innerHTML = screenshot.tags.map(tag => 
                    `<span class="tag">${tag} <button class="remove-tag" data-tag="${tag}">×</button></span>`
                ).join('');
            });
        }

        // Function to update the display of recent tags
        function updateRecentTagsDisplay() {
            requestAnimationFrame(() => {
                recentTagsContainer.innerHTML = Array.from(recentTags)
                    .filter(tag => !screenshot.tags.includes(tag))
                    .map(tag => `<button class="recent-tag">${tag}</button>`)
                    .join('');
            });
        }

        updateTagDisplay();
        updateRecentTagsDisplay();

        // Function to add a new tag
        function addTag(newTag) {
            if (newTag && !screenshot.tags.includes(newTag)) {
                screenshot.tags.push(newTag);
                recentTags.add(newTag);
                newTagInput.value = '';
                
                // Batch UI updates using requestAnimationFrame
                requestAnimationFrame(() => {
                    updateTagDisplay();
                    updateRecentTagsDisplay();
                    // Debounce the expensive operations
                    debouncedUpdateImageList();
                });
            }
        }

        // Event listener for adding new tag on Enter key press
        newTagInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addTag(newTagInput.value.trim());
            }
        });

        // Event listener for removing tags
        currentTags.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-tag')) {
                const tagToRemove = e.target.dataset.tag;
                screenshot.tags = screenshot.tags.filter(tag => tag !== tagToRemove);
                
                requestAnimationFrame(() => {
                    updateTagDisplay();
                    updateRecentTagsDisplay();
                    debouncedUpdateImageList();
                });
            }
        });

        // Event listener for adding recent tags
        recentTagsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('recent-tag')) {
                addTag(e.target.textContent);
            }
        });

        // NEW: Add mousedown/mouseup pattern for modal closing
        modal.addEventListener('mousedown', (e) => {
            if (e.target === modal) {
                modal.dataset.mousedownOutside = 'true';
            } else {
                modal.dataset.mousedownOutside = 'false';
            }
        });

        modal.addEventListener('mouseup', (e) => {
            if (e.target === modal && modal.dataset.mousedownOutside === 'true') {
                document.body.removeChild(modal);
            }
            modal.dataset.mousedownOutside = '';
        });

        // Function to focus on the input field
        const focusInput = () => {
            newTagInput.focus();
            newTagInput.select();
        };

        // Focus on the input field multiple times to ensure it gets focus
        focusInput();
        setTimeout(focusInput, 50);
        setTimeout(focusInput, 300);
    },

    filterImages: (searchTerm, selectedTag) => {
        const imageItems = domElements.imageList.querySelectorAll('.image-item');
        imageItems.forEach((item, index) => {
            const imageName = item.querySelector('.image-name').textContent.toLowerCase();
            const imageTags = item.querySelector('.image-tags').textContent.split(', ');

            const matchesSearch = imageName.includes(searchTerm) || imageTags.some(tag => tag.toLowerCase().includes(searchTerm));
            const matchesTag = selectedTag === '' || imageTags.includes(selectedTag);

            if (matchesSearch && matchesTag) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    },

    // Update tag filter dropdown
    updateTagFilterDropdown: () => {
        const tagFilter = document.getElementById('tagFilter');
        const allTags = new Set();

        constants.screenshots.forEach(screenshot => {
            screenshot.tags.forEach(tag => allTags.add(tag));
        });

tagFilter.innerHTML = '<option value="">All Tags</option>';
allTags.forEach(tag => {
    const option = document.createElement('option');
    option.value = tag;
    option.textContent = tag;
    tagFilter.appendChild(option);
});
},

// Update the tag filter dropdown with all unique tags from screenshots
updateTagFilter: () => {
    const tagFilter = document.getElementById('tagFilter');
    const currentValue = tagFilter.value;
    const allTags = new Set();

    // Collect all unique tags from all screenshots
    constants.screenshots.forEach(screenshot => {
        screenshot.tags.forEach(tag => allTags.add(tag));
    });

    // Clear existing options and add default "All Tags" option
    tagFilter.innerHTML = '<option value="">All Tags</option>';

    // Convert Set to Array, sort alphabetically, and add options
    Array.from(allTags)
        .sort((a, b) => a.localeCompare(b))
        .forEach(tag => {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            tagFilter.appendChild(option);
        });

    // Restore the previously selected value if it still exists
    if (Array.from(tagFilter.options).some(option => option.value === currentValue)) {
        tagFilter.value = currentValue;
    }

    // Disable the dropdown if there are no tags
    tagFilter.disabled = allTags.size === 0;
},

// Open the settings modal and initialize its content
openSettings: () => {
    domElements.settingsModal.classList.remove('hidden');
    ui.updateShortcutDisplay();
    
    // Set current color values in inputs
    document.getElementById('localBoxColor').value = constants.localBoxColor;
    document.getElementById('linkedBoxColor').value = constants.linkedBoxColor;
    document.getElementById('globalBoxColor').value = constants.globalBoxColor;
    document.getElementById('textboxColor').value = constants.textboxColor;

    // Store original values for potential cancellation
    domElements.settingsModal.dataset.originalLocalColor = constants.localBoxColor;
    domElements.settingsModal.dataset.originalLinkedColor = constants.linkedBoxColor;
    domElements.settingsModal.dataset.originalGlobalColor = constants.globalBoxColor;
    domElements.settingsModal.dataset.originalTextColor = constants.textboxColor;

    domElements.toolbar.classList.add('hidden');
    
    // Store original shortcuts
    constants.originalDrawBoxShortcut = { ...constants.drawBoxShortcut };
    constants.originalDrawTextShortcut = { ...constants.drawTextShortcut };

    // Add real-time color update listeners
    document.getElementById('localBoxColor').addEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('linkedBoxColor').addEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('globalBoxColor').addEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('textboxColor').addEventListener('input', ui.updateBoxColorsRealTime);
},

// Close the settings modal and reset any unsaved changes
closeSettings: () => {
    const savedSettings = localStorage.getItem(`${constants.APP_ID}-settings`);
    
    if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        constants.linkedBoxColor = settings.linkedBoxColor;
        constants.globalBoxColor = settings.globalBoxColor;
        constants.drawBoxShortcut = settings.drawBoxShortcut;
        constants.drawTextShortcut = settings.drawTextShortcut;
        constants.localBoxColor = settings.localBoxColor;
        constants.textboxColor = settings.textboxColor;
    } else {
        // Fallback to defaults if no saved settings
        constants.linkedBoxColor = '#3498db';
        constants.globalBoxColor = '#9b59b6';
        constants.drawBoxShortcut = { key: 'B', shiftKey: false, ctrlKey: false, altKey: false };
        constants.drawTextShortcut = { key: 'T', shiftKey: false, ctrlKey: false, altKey: false };
        constants.localBoxColor = '#4CAF50';
        constants.textboxColor = '#FFFFFF';
    }
    
    ui.updateBoxStyles();
    ui.updateShortcutDisplay();
    
    domElements.settingsModal.classList.add('hidden');

    document.getElementById('localBoxColor').removeEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('linkedBoxColor').removeEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('globalBoxColor').removeEventListener('input', ui.updateBoxColorsRealTime);
    document.getElementById('textboxColor').removeEventListener('input', ui.updateBoxColorsRealTime);
},

// Update box colors in real-time as the user changes them in the settings
updateBoxColorsRealTime: () => {
    constants.localBoxColor = document.getElementById('localBoxColor').value;
    constants.linkedBoxColor = document.getElementById('linkedBoxColor').value;
    constants.globalBoxColor = document.getElementById('globalBoxColor').value;
    constants.textboxColor = document.getElementById('textboxColor').value;
    ui.updateBoxStyles();
},

// Update the display of the draw box shortcut in the settings
updateShortcutDisplay: () => {
    // Update draw box shortcut display
    let boxShortcutText = '';
    const key = constants.drawBoxShortcut.key.toUpperCase();
    // If the pressed key is a modifier alone, don't duplicate it.
    if (key === 'SHIFT' || key === 'CONTROL' || key === 'ALT') {
        if (key === 'SHIFT') boxShortcutText = 'Shift';
        else if (key === 'CONTROL') boxShortcutText = 'Ctrl';
        else if (key === 'ALT') boxShortcutText = 'Alt';
    } else {
        if (constants.drawBoxShortcut.ctrlKey) boxShortcutText += 'Ctrl+';
        if (constants.drawBoxShortcut.altKey) boxShortcutText += 'Alt+';
        if (constants.drawBoxShortcut.shiftKey) boxShortcutText += 'Shift+';
        boxShortcutText += key;
    }
    domElements.drawBoxShortcutInput.value = boxShortcutText;

    // Update draw text shortcut display with the same fix
    let textShortcutText = '';
    const tKey = constants.drawTextShortcut.key.toUpperCase();
    if (tKey === 'SHIFT' || tKey === 'CONTROL' || tKey === 'ALT') {
        if (tKey === 'SHIFT') textShortcutText = 'Shift';
        else if (tKey === 'CONTROL') textShortcutText = 'Ctrl';
        else if (tKey === 'ALT') textShortcutText = 'Alt';
    } else {
        if (constants.drawTextShortcut.ctrlKey) textShortcutText += 'Ctrl+';
        if (constants.drawTextShortcut.altKey) textShortcutText += 'Alt+';
        if (constants.drawTextShortcut.shiftKey) textShortcutText += 'Shift+';
        textShortcutText += tKey;
    }
    document.getElementById('drawTextShortcut').value = textShortcutText;
},

// Save the current settings
saveSettings: () => {
    constants.drawBoxShortcut = ui.parseShortcut(domElements.drawBoxShortcutInput.value);
    constants.drawTextShortcut = ui.parseShortcut(document.getElementById('drawTextShortcut').value);
    constants.localBoxColor = document.getElementById('localBoxColor').value;
    constants.linkedBoxColor = document.getElementById('linkedBoxColor').value;
    constants.globalBoxColor = document.getElementById('globalBoxColor').value;
    constants.textboxColor = document.getElementById('textboxColor').value;
    
    // Save settings to localStorage with unique key
    const settings = {
        drawBoxShortcut: constants.drawBoxShortcut,
        drawTextShortcut: constants.drawTextShortcut,
        localBoxColor: constants.localBoxColor,
        linkedBoxColor: constants.linkedBoxColor,
        globalBoxColor: constants.globalBoxColor,
        textboxColor: constants.textboxColor
    };
    localStorage.setItem(`${constants.APP_ID}-settings`, JSON.stringify(settings));
    
    // Close the settings modal
    ui.closeSettings();
},

// Function to display help content in the help modal
displayHelpContent: () => {
    // Set the inner HTML of the help content element
    domElements.helpContent.innerHTML = `
        <h3>Welcome to the Interactive Screenshot Application</h3>
        <p>This application allows you to upload, organize, and annotate screenshots. Here are the key features:</p>
        <style>
            /* Styling for the help list */
            .help-list {
                list-style-type: none;
                padding-left: 0;
            }
            .help-list li {
                display: flex;
                align-items: center;
                margin-bottom: 3px;
            }
            .help-list i {
                width: 30px;
                font-size: 1.2em;
                text-align: center;
                margin-right: 10px;
                color: #4CAF50;
            }
            .help-list-section {
                margin-bottom: 20px;
            }
            .help-list-section h4 {
                color: #4CAF50;
                margin-bottom: 0px;
            }
        </style>

        <div class="help-list-section">
            <h4>Basic Features</h4>
            <ul class="help-list">
                <li><i class="fas fa-upload"></i> <strong>Upload Images:</strong> &nbsp;Click the upload button in the sidebar to add screenshots.</li>
                <li><i class="fas fa-draw-polygon"></i> <strong>Draw Boxes:</strong>&nbsp; Use the draw box tool (press 'B') to create annotations on images.</li>
                <li><i class="fas fa-font"></i> <strong>Draw Text Boxes:</strong>&nbsp; Use the text tool (press 'T') to add text annotations.</li>
                <li><i class="fas fa-link"></i> <strong>Link Boxes:</strong>&nbsp; Right-click on a box to link it to another image.</li>
                <li><i class="fas fa-globe"></i> <strong>Global Boxes:</strong>&nbsp; Create boxes that appear on multiple images.</li>
            </ul>
        </div>

        <div class="help-list-section">
            <h4>Organization & Management</h4>
            <ul class="help-list">
                <li><i class="fas fa-tags"></i> <strong>Tag System:</strong> &nbsp; Add and manage tags for better organization.</li>
                <li><i class="fas fa-search"></i> <strong>Search & Filter:</strong>  &nbsp;Search images by name or filter by tags.</li>
                <li><i class="fas fa-sort"></i> <strong>Drag & Drop:</strong>  &nbsp;Reorder images by dragging them in the sidebar.</li>
                <li><i class="fas fa-arrows-alt-h"></i> <strong>Resize Thumbnails:</strong> &nbsp; Use the slider to adjust sidebar thumbnail sizes.</li>
                <li><i class="fas fa-image"></i> <strong>Replace Images:</strong>  &nbsp;Right-click on an image to replace it.</li>
            </ul>
        </div>

        <div class="help-list-section">
            <h4>Advanced Features</h4>
            <ul class="help-list">
                <li><i class="fas fa-magnet"></i> <strong>Smart Snapping:</strong>  &nbsp;Boxes snap to align with other boxes and edges.</li>
                <li><i class="fas fa-eye"></i> <strong>Visibility Control:</strong>  &nbsp;Manage which images global boxes appear on.</li>
                <li><i class="fas fa-keyboard"></i> <strong>Customizable Shortcuts:</strong> &nbsp; Configure keyboard shortcuts in settings.</li>
                <li><i class="fas fa-palette"></i> <strong>Color Customization:</strong> &nbsp; Customize colors for linked and global boxes.</li>
            </ul>
        </div>

        <div class="help-list-section">
            <h4>Project Management</h4>
            <ul class="help-list">
                <li><i class="fas fa-save"></i> <strong>Save Projects:</strong> &nbsp; Save your work as an interactive HTML file.</li>
                <li><i class="fas fa-folder-open"></i> <strong>Open Projects:</strong>  &nbsp;Load previously saved projects.</li>
                <li><i class="fas fa-undo"></i> <strong>Cancel Operations:</strong> &nbsp; Press 'Esc' to cancel current box operations.</li>
            </ul>
        </div>

        <div class="help-list-section">
            <h4>Tips</h4>
            <ul class="help-list">
                <li><i class="fas fa-info-circle"></i> Hover over buttons to see tooltips.</li>
                <li><i class="fas fa-info-circle"></i> Right-click on boxes or images for context menus.</li>
                <li><i class="fas fa-info-circle"></i> Use tags in filenames with [tag] format for automatic tagging.</li>
                <li><i class="fas fa-info-circle"></i> Click on text boxes to edit their content.</li>
            </ul>
        </div>
    `;
},

    // NEW: Show image-specific context menu with "Replace Image" option
    showImageContextMenu: (e) => {
        e.preventDefault();
        // Build the menu options for the image (expandable later)
        const menuItems = {
            replaceImage: { id: 'replaceImage', icon: 'fa-solid fa-image', title: 'Replace Image', color: '#FF9800' }
        };
        let menuContent = '';
        Object.values(menuItems).forEach(item => {
            menuContent += `<li id="${item.id}" title="${item.title}" data-color="${item.color}"><i class="fas ${item.icon}"></i> ${item.title}</li>`;
        });
        // Set the context menu's inner HTML
        domElements.contextMenu.querySelector('ul').innerHTML = menuContent;
        
        // Bind the click handler for the replace image option
        const replaceBtn = document.getElementById('replaceImage');
        if (replaceBtn) {
            replaceBtn.onclick = ui.replaceImage;
        }
        
        // Simple positioning: place context menu at the mouse pointer
        const contextMenu = domElements.contextMenu;
        contextMenu.classList.remove('hidden', 'vertical');
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        let left = e.clientX;
        let top = e.clientY;
        // Adjust if menu goes off-screen
        if (left + contextMenu.offsetWidth > viewportWidth) {
            left = viewportWidth - contextMenu.offsetWidth - 10;
        }
        if (top + contextMenu.offsetHeight > viewportHeight) {
            top = viewportHeight - contextMenu.offsetHeight - 10;
        }
        contextMenu.style.left = `${left}px`;
        contextMenu.style.top = `${top}px`;
    },

    // NEW: Function to handle "Replace Image" action
    replaceImage: () => {
        // Hide the context menu to start the action
        domElements.contextMenu.classList.add('hidden');
        // Create a hidden file input for image replacement
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.style.display = 'none';
        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const newImageData = ev.target.result;
                    // Update the screenshot data for the current screenshot
                    const currentIndex = constants.currentScreenshotIndex;
                    if (currentIndex >= 0 && currentIndex < constants.screenshots.length) {
                        // Update the screenshot data with the new image
                        constants.screenshots[currentIndex].data = newImageData;
                        // UPDATED: Refresh the sidebar thumbnail list
                        core.updateImageList();

                        const img = domElements.imageContainer.querySelector('img');
                        if (img) {
                            img.src = newImageData;
                            img.onload = () => {
                                core.scaleImage();
                                core.displayBoxes();
                                ui.preventImageDrag();
                            }
                        }
                    }
                };
                reader.readAsDataURL(file);
            }
            // Clean up the temporary input element
            input.remove();
        });
        document.body.appendChild(input);
        input.click();
    },

    // Add these new functions (for example, after the updateShortcutDisplay function) in your ui object:

    openSaveProjectModal: () => {
        // Prepare UI for saving
        if (constants.screenshots.length > 0) {
            constants.currentScreenshotIndex = 0;
            core.displayScreenshot(0);
        }
        constants.showUIElements = false;
        ui.updateUIVisibility();
      
        domElements.toolbar.classList.add('hidden');
        domElements.contextMenu.classList.add('hidden');
        domElements.sideToolbarWrapper.classList.add('hidden');
        domElements.sideToolbarToggle.style.left = '0px';
        domElements.imageContainer.style.marginLeft = '20px';

        // Prepare project data for export
        const projectData = {
            isSavedProject: true,
            showUIElements: false,
            screenshots: constants.screenshots.map(screenshot => ({
                name: screenshot.name,
                data: screenshot.data,
                tags: screenshot.tags || []  // Use empty array if tags are not present
            })),
            boxes: constants.boxes.map(box => ({
                ...box,
                linkedTo: box.linkedTo !== null ? box.linkedTo : null
            })),
            globalBoxes: constants.globalBoxes.map(box => ({
                ...box,
                linkedTo: box.linkedTo !== null ? box.linkedTo : null
            })),
            textBoxes: constants.textBoxes,
            globalTextBoxes: constants.globalTextBoxes,
            linkedBoxColor: constants.linkedBoxColor,
            globalBoxColor: constants.globalBoxColor
        };

        const serializedData = JSON.stringify(projectData);

        const dataScript = document.createElement('script');
        dataScript.id = 'projectData';
        dataScript.type = 'application/json';
        dataScript.textContent = serializedData;

        const existingDataScript = document.getElementById('projectData');
        if (existingDataScript) {
            existingDataScript.replaceWith(dataScript);
        } else {
            document.body.appendChild(dataScript);
        }

        // Generate the complete HTML content for the export and store it
        constants.projectHTMLContent = document.documentElement.outerHTML;

        // Now, display the save project modal popup
        const modal = document.getElementById('saveProjectModal');
        modal.classList.remove('hidden');

        // Set up modal button event handlers
        const saveConfirmBtn = document.getElementById('saveProjectConfirm');
        const saveCancelBtn = document.getElementById('saveProjectCancel');

        saveConfirmBtn.onclick = ui.confirmSaveProject;
        saveCancelBtn.onclick = ui.cancelSaveProject;

        // NEW: Add keydown event listener to input field
        const saveProjectFilenameInput = document.getElementById('saveProjectFilename');
        saveProjectFilenameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission if inside a form
                ui.confirmSaveProject(); // Call the save function
            }
        });
    },

    confirmSaveProject: () => {
        const input = document.getElementById('saveProjectFilename');
        const fileName = input.value || "interactive_screenshot_app.html";
        const blob = new Blob([constants.projectHTMLContent], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);

        // Close the modal and restore the UI elements
        document.getElementById('saveProjectModal').classList.add('hidden');
        setTimeout(() => {
            constants.showUIElements = true;
            ui.updateUIVisibility();
        }, 100);
    },

    cancelSaveProject: () => {
        // Simply close the modal and restore the UI without saving
        document.getElementById('saveProjectModal').classList.add('hidden');
        setTimeout(() => {
            constants.showUIElements = true;
            ui.updateUIVisibility();
        }, 100);
    },

    // Add this function to the ui object, before saveSettings
    parseShortcut: (shortcutText) => {
        // Handle empty input
        if (!shortcutText) {
            return { key: '', shiftKey: false, ctrlKey: false, altKey: false };
        }

        // Split the shortcut text into parts
        const parts = shortcutText.split('+').map(part => part.trim().toUpperCase());
        
        // Initialize shortcut object
        const shortcut = {
            key: '',
            shiftKey: false,
            ctrlKey: false,
            altKey: false
        };

        // Process each part
        parts.forEach(part => {
            switch (part) {
                case 'CTRL':
                    shortcut.ctrlKey = true;
                    break;
                case 'SHIFT':
                    shortcut.shiftKey = true;
                    break;
                case 'ALT':
                    shortcut.altKey = true;
                    break;
                default:
                    shortcut.key = part;
            }
        });

        // If the only key is a modifier, make it the main key
        if (!shortcut.key && (shortcut.ctrlKey || shortcut.shiftKey || shortcut.altKey)) {
            if (shortcut.ctrlKey) {
                shortcut.key = 'CONTROL';
                shortcut.ctrlKey = false;
            } else if (shortcut.shiftKey) {
                shortcut.key = 'SHIFT';
                shortcut.shiftKey = false;
            } else if (shortcut.altKey) {
                shortcut.key = 'ALT';
                shortcut.altKey = false;
            }
        }

        return shortcut;
    },

    showFlowchart: () => {
        console.log('Generating flowchart visualization...');
        const container = document.getElementById('flowchartContainer');
        container.innerHTML = ''; // Clear previous content

        // Create main transform container
        const transformContainer = document.createElement('div');
        transformContainer.style.transformOrigin = '0 0';
        container.appendChild(transformContainer);

        // Create SVG element for connections
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.position = 'absolute';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        transformContainer.appendChild(svg);

        // Create node container
        const nodesContainer = document.createElement('div');
        nodesContainer.style.position = 'relative';
        nodesContainer.style.minHeight = '100%';
        transformContainer.appendChild(nodesContainer);

        // Calculate layout parameters with more spacing
        const NODE_WIDTH = 200;
        const NODE_HEIGHT = 140;
        const HORIZONTAL_SPACING = 150;  // Increased from 100
        const VERTICAL_SPACING = 120;     // Increased from 80
        
        // Store node positions and connection data
        const nodePositions = new Map();
        const connectionMap = new Map();
        let maxRowHeight = 0;

        // Create screenshot nodes with improved layout logic
        let currentRow = 0;
        let currentCol = 0;
        let maxCols = 3;
        
        constants.screenshots.forEach((screenshot, index) => {
            const node = document.createElement('div');
            node.className = 'flow-node';
            node.innerHTML = `
                <img src="${screenshot.data}" alt="${screenshot.name}">
                <div class="title">${screenshot.name}</div>
            `;
            
            // Calculate position with dynamic row breaks
            const x = currentCol * (NODE_WIDTH + HORIZONTAL_SPACING) + 50;
            const y = currentRow * (NODE_HEIGHT + VERTICAL_SPACING) + 50;
            
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.width = `${NODE_WIDTH}px`;
            node.style.height = `${NODE_HEIGHT}px`;
            
            // Store position for connection calculations
            nodePositions.set(index, {
                x: x + NODE_WIDTH/2,
                y: y + NODE_HEIGHT/2,
                width: NODE_WIDTH,
                height: NODE_HEIGHT,
                nodeElement: node
            });

            // Update layout counters
            currentCol++;
            if (currentCol >= maxCols) {
                currentCol = 0;
                currentRow++;
            }

            // --- Modified click handling for flowchart node ---
            // Instead of a simple click handler, we add mousedown and mouseup events.
            // If the total movement is less than 5px, then we trigger navigation (i.e. go into that node).
            node.addEventListener('mousedown', (e) => {
                node.dataset.startX = e.clientX;
                node.dataset.startY = e.clientY;
            });
            node.addEventListener('mouseup', (e) => {
                const startX = parseFloat(node.dataset.startX) || 0;
                const startY = parseFloat(node.dataset.startY) || 0;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const threshold = 5; // pixels
                if (distance < threshold) {
                    // Only trigger the click action if not panning
                    core.displayScreenshot(index);
                    document.getElementById('flowchartModal').classList.add('hidden');
                }
            });
            // --- End modified click handling ---

            nodesContainer.appendChild(node);
            maxRowHeight = Math.max(maxRowHeight, y + NODE_HEIGHT);
        });

        // Set container size based on content
        nodesContainer.style.width = `${maxCols * (NODE_WIDTH + HORIZONTAL_SPACING)}px`;
        nodesContainer.style.height = `${maxRowHeight + 100}px`;

        // Create connections with dynamic curvature based on direction
        constants.boxes.forEach(box => {
            if (box.linkedTo !== null && box.linkedTo !== undefined) {
                const from = box.screenshotIndex;
                const to = box.linkedTo;
                const key = `${from}-${to}`;
                
                if (!connectionMap.has(key)) {
                    connectionMap.set(key, {
                        count: 1,
                        from,
                        to
                    });
                } else {
                    connectionMap.get(key).count++;
                }
            }
        });

        connectionMap.forEach((connection, key) => {
            const start = nodePositions.get(connection.from);
            const end = nodePositions.get(connection.to);
            
            if (start && end) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Dynamic curvature based on connection count and direction
                const curveStrength = Math.min(200, distance/2) * (1 + (connection.count % 3));
                const curveOffset = 30 * connection.count;
                
                path.setAttribute('d', `M ${start.x} ${start.y} 
                    Q ${start.x + curveStrength + curveOffset} ${start.y - curveOffset},
                    ${end.x} ${end.y}`);
                
                path.setAttribute('stroke', constants.linkedBoxColor);
                path.setAttribute('stroke-width', `${1 + connection.count/2}`);
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.style.opacity = 0.7;
                svg.appendChild(path);
            }
        });

        // --- Zoom and Pan Handlers ---
        // Set initial pan and scale values
        let scaleValue = 1;
        let panX = 0, panY = 0;
        // Hint for GPU acceleration
        transformContainer.style.willChange = 'transform';

        // Use requestAnimationFrame to throttle zoom events
        let pendingWheelEvent = null;
        let wheelRunning = false;
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            pendingWheelEvent = e;
            if (!wheelRunning) {
                wheelRunning = true;
                requestAnimationFrame(() => {
                    const evt = pendingWheelEvent;
                    const delta = evt.deltaY > 0 ? 0.9 : 1.1;
                    scaleValue *= delta;
                    const rect = container.getBoundingClientRect();
                    const mouseX = evt.clientX - rect.left;
                    const mouseY = evt.clientY - rect.top;
                    transformContainer.style.transformOrigin = `${mouseX}px ${mouseY}px`;
                    // Use translate3d for smoother GPU-accelerated transitions
                    transformContainer.style.transform = `translate3d(${panX}px, ${panY}px, 0) scale(${scaleValue})`;
                    wheelRunning = false;
                });
            }
        });

        // Pan: update panX/panY on mouse drag remains the same:
        let isPanning = false, startPanX = 0, startPanY = 0;
        container.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isPanning = true;
            startPanX = e.clientX;
            startPanY = e.clientY;
        });
        container.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - startPanX;
            const dy = e.clientY - startPanY;
            startPanX = e.clientX;
            startPanY = e.clientY;
            panX += dx;
            panY += dy;
            transformContainer.style.transform = `translate3d(${panX}px, ${panY}px, 0) scale(${scaleValue})`;
        });
        container.addEventListener('mouseup', () => { isPanning = false; });
        container.addEventListener('mouseleave', () => { isPanning = false; });

        // Reset Zoom Button: resets scale and pan to defaults
        const resetZoom = document.createElement('button');
        resetZoom.className = 'btn btn-positive';
        resetZoom.style.position = 'absolute';
        resetZoom.style.top = '10px';
        resetZoom.style.right = '10px';
        resetZoom.textContent = 'Reset View';
        resetZoom.addEventListener('click', () => {
            scaleValue = 1; panX = 0; panY = 0;
            transformContainer.style.transform = `translate(0px,0px) scale(1)`;
            container.scrollTo(0, 0);
        });
        container.appendChild(resetZoom);

        // ---- Adjust positions of nodes with incoming links ----
        const pullFactor = 0.2; // Adjust factor (0.0 - 1.0) to control closeness
        const targetConnections = new Map();
        connectionMap.forEach((conn) => {
            // For each connection, add source node for target node
            if (!targetConnections.has(conn.to)) {
                targetConnections.set(conn.to, []);
            }
            targetConnections.get(conn.to).push(nodePositions.get(conn.from));
        });

        targetConnections.forEach((sources, targetIndex) => {
            const targetData = nodePositions.get(targetIndex);
            if (targetData) {
                let avgX = 0, avgY = 0;
                sources.forEach(source => {
                    avgX += source.x;
                    avgY += source.y;
                });
                avgX /= sources.length;
                avgY /= sources.length;
                // Pull target position 20% toward the average source position
                const newX = targetData.x - pullFactor * (targetData.x - avgX);
                const newY = targetData.y - pullFactor * (targetData.y - avgY);
                targetData.x = newX;
                targetData.y = newY;
                // Update the corresponding node's DOM position
                if (targetData.nodeElement) {
                    targetData.nodeElement.style.left = `${newX - NODE_WIDTH/2}px`;
                    targetData.nodeElement.style.top  = `${newY - NODE_HEIGHT/2}px`;
                }
            }
        });
    },
};

// Event Listeners
const eventListeners = {
    // Initialize all event listeners for the application
    initializeEventListeners: () => {
        // Image size slider event
        domElements.imageSizeSlider.addEventListener('input', ui.updateImageSize);

        // Project management events
        domElements.openProjectBtn.addEventListener('click', eventListeners.openProject);
        domElements.saveProjectBtn.addEventListener('click', eventListeners.saveProject);
        domElements.helpIcon.addEventListener('click', ui.showHelpModal);
        domElements.settingsBtn.addEventListener('click', ui.showSettingsModal);

        // Settings events
        domElements.settingsBtn.addEventListener('click', ui.openSettings);
        

        // Sidebar toggle event
        domElements.sideToolbarToggle.addEventListener('click', () => {
            ui.toggleSidebar();
            ui.updateGlowIndicators();
        });
        
        // Drawing box events
        domElements.imageContainer.addEventListener('mousedown', (e) => {
            if (constants.isDrawingText) {
                core.startDrawingText(e);
            } else if (constants.isDrawing) {
                core.startDrawing(e);
            }
        });
        domElements.imageContainer.addEventListener('mousemove', (e) => {
            if (constants.isDrawingText) {
                core.drawTextBox(e);
            } else if (constants.isDrawing) {
                core.drawBox(e);
            }
        });
        domElements.imageContainer.addEventListener('mouseup', (e) => {
            if (constants.isDrawingText) {
                core.endDrawingText();
            } else if (constants.isDrawing) {
                core.endDrawing();
            }
        });

        // Shortcut input event
        domElements.drawBoxShortcutInput.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                e.preventDefault();
                return;
            }
            e.preventDefault();
            constants.drawBoxShortcut = {
                key: e.key.toUpperCase(),
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey
            };
            ui.updateShortcutDisplay();
        });

        // Help modal events
        domElements.helpIcon.addEventListener('click', () => {
            domElements.helpModal.classList.remove('hidden');
            ui.displayHelpContent();
        });
        

        // Other UI events
        domElements.deleteAllScreenshotsBtn.addEventListener('click', eventListeners.deleteAllScreenshots);
        domElements.saveProjectBtn.addEventListener('click', eventListeners.saveProject);
        domElements.drawBoxBtn.addEventListener('click', eventListeners.toggleDrawBox);
        domElements.toolbarIcon.addEventListener('click', eventListeners.toggleToolbar);
        domElements.uploadScreenshotInput.addEventListener('change', eventListeners.uploadScreenshot);

        // Global document events
        document.addEventListener('click', () => domElements.contextMenu.classList.add('hidden'));
        document.addEventListener('DOMContentLoaded', ui.setInitialLayout);
        document.addEventListener('DOMContentLoaded', core.initializeApp);
        document.addEventListener('keydown', eventListeners.handleKeyboardShortcuts);

        // Window resize event
        window.addEventListener('resize', () => {
            ui.handleResize();
            ui.updateImageSize();
        });

        // Image search and filter events
        document.getElementById('imageSearch').addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            const selectedTag = document.getElementById('tagFilter').value;
            ui.filterImages(searchTerm, selectedTag);
        });
        document.getElementById('tagFilter').addEventListener('change', function() {
            const searchTerm = document.getElementById('imageSearch').value.toLowerCase();
            const selectedTag = this.value;
            ui.filterImages(searchTerm, selectedTag);
        });

        // Prevent zoom gestures
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gesturechange', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gestureend', function(e) {
            e.preventDefault();
        });

        // Prevent mousewheel zoom
        document.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
            }
        }, { passive: false });

        // Prevent pinch zoom on touchpads
        document.addEventListener('touchmove', function(e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // NEW: Add a contextmenu listener on the image container
        domElements.imageContainer.addEventListener('contextmenu', (e) => {
            // If the right-click is on the main image (not a box), show the image context menu.
            if (e.target.tagName.toLowerCase() === 'img') {
                ui.showImageContextMenu(e);
            }
        });

        // Add event listener for draw text shortcut input
        document.getElementById('drawTextShortcut').addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                e.preventDefault();
                return;
            }
            e.preventDefault();
            constants.drawTextShortcut = {
                key: e.key.toUpperCase(),
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey
            };
            ui.updateShortcutDisplay();
        });

        // Add Escape key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                core.cancelCurrentOperation();
            }
        });

        // Add flowchart button event listener
        domElements.showFlowchart.addEventListener('click', () => {
            console.log('Flowchart button clicked'); // Debug log
            const modal = document.getElementById('flowchartModal');
            if (modal) {
                modal.classList.remove('hidden');
                ui.showFlowchart();
            } else {
                console.error('Flowchart modal not found');
            }
        });
        
        document.getElementById('flowchartModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('flowchartModal')) {
                    document.getElementById('flowchartModal').classList.add('hidden');
            }
            });

    },

    // Function to open a project file
    openProject: () => {
        // Create a file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.html';

        domElements.toolbar.classList.add('hidden');
        
        // Add event listener for file selection
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const htmlContent = e.target.result;
                    // Parse the HTML content
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    // Find the project data script
                    const projectDataScript = doc.querySelector('#projectData');
                    if (projectDataScript) {
                        // Parse and load the project data
                        const projectData = JSON.parse(projectDataScript.textContent);
                        core.loadProjectData(projectData, true);
                    } else {
                        alert('Invalid project file.');
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Trigger file selection dialog
        fileInput.click();
    },

    // Function to delete all screenshots
    deleteAllScreenshots: () => {
        if (confirm('Are you sure you want to delete all images? This action cannot be undone.')) {
            // Clear all data
            constants.screenshots = [];
            constants.boxes = [];
            constants.globalBoxes = [];
            constants.currentScreenshotIndex = -1;
            constants.currentScreenshot = null;
            domElements.imageContainer.innerHTML = '';
            core.updateImageList();
            
            // Update the tag filter dropdown
            ui.updateTagFilter();
            
            // Show placeholder message
            const placeholderMessage = document.getElementById('placeholderMessage');
            if (placeholderMessage) {
                placeholderMessage.style.display = 'flex';
                if (!domElements.imageContainer.contains(placeholderMessage)) {
                    domElements.imageContainer.appendChild(placeholderMessage);
                }
            } else {
                // Create new placeholder if it doesn't exist
                const newPlaceholder = document.createElement('div');
                newPlaceholder.id = 'placeholderMessage';
                newPlaceholder.className = 'placeholder-message';
                newPlaceholder.innerHTML = `
                    <div class="placeholder-content">
                        <i class="fas fa-image fa-10x"></i>
                        <h2>No Images Added</h2>
                        <p>Upload screenshots to get started</p>
                        <p>Click the <i class="fas fa-upload"></i> button in the sidebar</p>
                    </div>
                `;
                newPlaceholder.style.display = 'flex';
                domElements.imageContainer.appendChild(newPlaceholder);
            }
        }
    },

    // Function to save the current project
    saveProject: () => {
        ui.openSaveProjectModal();
    },

    // Function to toggle draw box mode
    toggleDrawBox: () => {
        // If no image is loaded, do not enable draw box mode.
        if (!domElements.imageContainer.querySelector('img')) {
            console.log("No image loaded. Cannot enable draw box mode.");
            return;
        }
        // Existing functionality:
        constants.isDrawing = !constants.isDrawing;
        domElements.imageContainer.style.cursor = constants.isDrawing ? 'crosshair' : 'default';
        domElements.drawBoxBtn.classList.toggle('active', constants.isDrawing);
        if (constants.isDrawing) {
            core.initializeDrawing();
            ui.showModeIndicator('Draw Box Mode', 'fa-draw-polygon');
        } else {
            ui.hideModeIndicator();
        }
    },

    // Function to toggle toolbar visibility
    toggleToolbar: (e) => {
        e.stopPropagation();
        domElements.toolbar.classList.toggle('hidden');
    },

    // Function to handle screenshot upload
    uploadScreenshot: (e) => {
        const files = Array.from(e.target.files);
        
        if (files.length === 0) {
            console.log('No files selected');
            return;
        }

        // Remove any existing loading indicator
        const existingIndicator = domElements.imageList.querySelector('.loading-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }

        // Show loading indicator at the top of the image list
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'loading-indicator';
        loadingIndicator.innerHTML = `
            <span>Loading images...</span>
            <div class="progress"></div>
        `;
        domElements.imageList.insertBefore(loadingIndicator, domElements.imageList.firstChild);

        // Update the progress display with:
        const updateProgress = (progress) => {
            const progressBar = loadingIndicator.querySelector('.progress');
            progressBar.style.width = `${progress}%`;
            loadingIndicator.querySelector('span').textContent = `Loading images... ${progress}%`;
        };

        // Helper functions
        const extractTags = (filename) => {
            const tagRegex = /\[([^\]]+)\]/g;
            const tags = [];
            let match;
            while ((match = tagRegex.exec(filename)) !== null) {
                tags.push(match[1]);
            }
            return tags;
        };

        const cleanFileName = (filename) => {
            return filename.replace(/\[[^\]]+\]/g, '') // Remove tags
                        .replace(/\.[^/.]+$/, '')   // Remove file extension
                        .trim();
        };

        const naturalSort = (a, b) => {
            const aParts = a.name.match(/(\D+)(\d+)/);
            const bParts = b.name.match(/(\D+)(\d+)/);
            
            if (aParts && bParts) {
                const aPrefix = aParts[1];
                const bPrefix = bParts[1];
                const aNum = parseInt(aParts[2]);
                const bNum = parseInt(bParts[2]);
                
                if (aPrefix !== bPrefix) {
                    return aPrefix.localeCompare(bPrefix);
                }
                return aNum - bNum;
            }
            return a.name.localeCompare(b.name);
        };

        // Process files in batches
        const batchSize = 5;
        const totalBatches = Math.ceil(files.length / batchSize);
        let currentBatch = 0;

        const processNextBatch = () => {
            const start = currentBatch * batchSize;
            const end = Math.min(start + batchSize, files.length);
            const currentFiles = files.slice(start, end);

            Promise.all(currentFiles.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const tags = extractTags(file.name);
                        const cleanName = cleanFileName(file.name);
                        
                        // Create and load image to get dimensions
                        const img = new Image();
                        img.onload = () => {
                            resolve({ 
                                name: cleanName, 
                                data: e.target.result, 
                                tags: tags,
                                originalName: file.name,
                                baseWidth: img.naturalWidth,
                                baseHeight: img.naturalHeight
                            });
                        };
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            })).then(newScreenshots => {
                // Update progress indicator with percentage
                const progress = Math.round((Math.min(end, files.length) / files.length) * 100);
                updateProgress(progress);

                // --- NEW CODE: Create index mapping BEFORE merging ---
                const oldIndexToNewIndex = new Map();
                constants.screenshots.forEach((screenshot, oldIndex) => {
                    oldIndexToNewIndex.set(oldIndex, oldIndex); // Initially, new index is the same as old index
                });
                // --- END NEW CODE ---

                // Merge new screenshots with existing ones
                const originalScreenshotCount = constants.screenshots.length;
                const allScreenshots = [...constants.screenshots, ...newScreenshots];
                allScreenshots.sort(naturalSort);

                // --- NEW CODE: Update the mapping with new indices ---
                allScreenshots.forEach((screenshot, newIndex) => {
                    // --- UPDATED: Use both name AND data for uniqueness ---
                    const oldIndex = constants.screenshots.findIndex(s => s.name === screenshot.name && s.data === screenshot.data);
                    if (oldIndex !== -1) {
                        oldIndexToNewIndex.set(oldIndex, newIndex);
                    }
                });
                // --- END NEW CODE ---

                // Batch update all arrays
                requestAnimationFrame(() => {
                    // Update screenshots array
                    constants.screenshots = allScreenshots;

                    // --- UPDATED CODE: Use the mapping for all updates ---
                    constants.boxes.forEach(box => {
                        box.screenshotIndex = oldIndexToNewIndex.get(box.screenshotIndex);
                        box.linkedTo = box.linkedTo !== null ? oldIndexToNewIndex.get(box.linkedTo) : null;
                    });

                    constants.globalBoxes.forEach(box => {
                        box.visibleOn = box.visibleOn.map(oldIndex => oldIndexToNewIndex.get(oldIndex));
                        box.linkedTo = box.linkedTo !== null ? oldIndexToNewIndex.get(box.linkedTo) : null;
                    });

                    constants.textBoxes.forEach(textBox => {
                        textBox.screenshotIndex = oldIndexToNewIndex.get(textBox.screenshotIndex);
                    });

                    constants.globalTextBoxes.forEach(textBox => {
                        textBox.visibleOn = textBox.visibleOn.map(oldIndex => oldIndexToNewIndex.get(oldIndex));
                    });

                    // Update currentScreenshotIndex if it was set
                    if(constants.currentScreenshotIndex != -1){
                        constants.currentScreenshotIndex = oldIndexToNewIndex.get(constants.currentScreenshotIndex);
                    }
                    // --- END UPDATED CODE ---

                    // Process next batch or finish
                    currentBatch++;
                    if (currentBatch < totalBatches) {
                        processNextBatch();
                    } else {
                        // Final UI updates
                        // Add a small delay before removing the indicator
                        setTimeout(() => {
                            loadingIndicator.style.opacity = '0';
                            setTimeout(() => loadingIndicator.remove(), 300);
                        }, 500);

                        // Efficiently update UI
                        const updateUI = () => {
                            core.updateImageList();
                            if (originalScreenshotCount === 0) {
                                core.displayScreenshot(0);
                            } else {
                                const firstNewIndex = constants.screenshots.findIndex(s => 
                                    newScreenshots.some(ns => ns.name === s.name)
                                );
                                core.displayScreenshot(firstNewIndex);
                            }
                            
                            const placeholderMessage = document.getElementById('placeholderMessage');
                            if (placeholderMessage) {
                                placeholderMessage.style.display = 'none';
                            }
                            
                            ui.updateGlowIndicators();
                            ui.updateTagFilter();
                        };

                        // Use requestAnimationFrame for smooth UI updates
                        requestAnimationFrame(updateUI);
                    }
                });
            }).catch(error => {
                console.error('Error processing batch:', error);
                loadingIndicator.innerHTML = `
                    <span style="color: #ff4433;">Error loading images. Please try again.</span>
                `;
                loadingIndicator.style.backgroundColor = '#ff44331a';
                setTimeout(() => {
                    loadingIndicator.style.opacity = '0';
                    setTimeout(() => loadingIndicator.remove(), 300);
                }, 3000);
            });
        };

        // Start processing the first batch
        processNextBatch();
        
        // Reset file input
        e.target.value = '';
    },

    // Function to handle keyboard shortcuts
    handleKeyboardShortcuts: (event) => {
        // First check if it's the Escape key
        if (event.key === "Escape") {
            const activeEl = document.activeElement;
            // If focused on a shortcut input, prevent default but don't close modal
            if (activeEl && (activeEl.id === 'drawBoxShortcut' || activeEl.id === 'drawTextShortcut')) {
                event.preventDefault();
                return;
            }

            // Rest of the existing ESC handling code...
            const modals = [
                domElements.helpModal,
                domElements.settingsModal,
                document.querySelector('.tag-manager-modal'),
                document.querySelector('.modal-overlay'),
                document.getElementById('saveProjectModal')
            ];

            let modalClosed = false;
            modals.forEach(modal => {
                if (modal && !modal.classList.contains('hidden')) {
                    modal.classList.add('hidden');
                    modalClosed = true;
                    
                    // If it's the settings modal, save settings
                    if (modal === domElements.settingsModal) {
                        ui.saveSettings();
                    }
                    
                    // If it's the save project modal, cancel save
                    if (modal.id === 'saveProjectModal') {
                        ui.cancelSaveProject();
                    }
                }
            });

            // If we closed a modal, return early
            if (modalClosed) {
                return;
            }

            // If no modal was closed, proceed with existing cancel operation
            core.cancelCurrentOperation();
            return;
        }

        // Rest of the existing shortcut handling code...
        const activeEl = document.activeElement;
        if (activeEl && (activeEl.tagName.toLowerCase() === 'input' ||
                         activeEl.tagName.toLowerCase() === 'textarea' ||
                         activeEl.isContentEditable)) {
            return;
        }
        if (event.key.toUpperCase() === constants.drawBoxShortcut.key &&
            event.shiftKey === constants.drawBoxShortcut.shiftKey &&
            event.ctrlKey === constants.drawBoxShortcut.ctrlKey &&
            event.altKey === constants.drawBoxShortcut.altKey) {
            event.preventDefault();
            
            if (constants.screenshots.length > 0 && constants.showUIElements) {
                constants.isDrawing = !constants.isDrawing;
                domElements.imageContainer.style.cursor = constants.isDrawing ? 'crosshair' : 'default';
                domElements.drawBoxBtn.classList.toggle('active', constants.isDrawing);
                if (constants.isDrawing) {
                    ui.showModeIndicator('Draw Box Mode', 'fa-draw-polygon');
                } else {
                    ui.hideModeIndicator();
                }
                console.log('Draw rectangle tool toggled:', constants.isDrawing);
            } else if (constants.screenshots.length === 0) {
                console.log('No images added. Cannot toggle draw rectangle tool.');
            } else if (!constants.showUIElements) {
                console.log('UI elements are hidden. Cannot toggle draw rectangle tool.');
            }
        }
        // NEW: Handle draw text shortcut:
        if (event.key.toUpperCase() === constants.drawTextShortcut.key &&
            event.shiftKey === constants.drawTextShortcut.shiftKey &&
            event.ctrlKey === constants.drawTextShortcut.ctrlKey &&
            event.altKey === constants.drawTextShortcut.altKey) {
            event.preventDefault();
            if (constants.screenshots.length > 0 && constants.showUIElements) {
                // Toggle text drawing mode. Also disable normal box mode if active.
                constants.isDrawingText = !constants.isDrawingText;
                if (constants.isDrawingText) {
                    constants.isDrawing = false;
                    domElements.drawBoxBtn.classList.remove('active');
                }
                domElements.imageContainer.style.cursor = constants.isDrawingText ? 'crosshair' : 'default';
                if (constants.isDrawingText) {
                    ui.showModeIndicator('Draw Text Box Mode', 'fa-font');
                } else {
                    ui.hideModeIndicator();
                }
                console.log('Draw text box tool toggled:', constants.isDrawingText);
            } else if (constants.screenshots.length === 0) {
                console.log('No images added. Cannot toggle draw text box tool.');
            } else if (!constants.showUIElements) {
                console.log('UI elements are hidden. Cannot toggle draw text box tool.');
            }
        }
    },
};

// Initialization function
const init = () => {
    // Load settings from localStorage using unique key
    const savedSettings = localStorage.getItem(`${constants.APP_ID}-settings`);
    if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        constants.localBoxColor = settings.localBoxColor || '#4CAF50';
        constants.linkedBoxColor = settings.linkedBoxColor || '#3498db';
        constants.globalBoxColor = settings.globalBoxColor || '#9b59b6';
        constants.textboxColor = settings.textboxColor || '#be2d4c';
        constants.drawBoxShortcut = settings.drawBoxShortcut || { key: 'B', shiftKey: false, ctrlKey: false, altKey: false };
        constants.drawTextShortcut = settings.drawTextShortcut || { key: 'T', shiftKey: false, ctrlKey: false, altKey: false };
    }

    // Set up event listeners
    eventListeners.initializeEventListeners();
    // Set initial layout
    ui.setInitialLayout();
    // Initialize the application
    core.initializeApp();

    // Configure image size slider
    domElements.imageSizeSlider.min = 1;
    domElements.imageSizeSlider.max = 4;
    domElements.imageSizeSlider.value = 2;

    // Initialize the modeIndicator
    constants.modeIndicator = domElements.modeIndicator;

    // Update image size based on slider value
    ui.updateImageSize();
    // Handle initial window size
    ui.handleResize();
    // Update glow indicators for UI elements
    ui.updateGlowIndicators();
    // Update styles for boxes
    ui.updateBoxStyles();
};

// Start the application when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', init);

// Initialize Sortable for image list when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    let autoScrollInterval;
    let draggedIndex;

    new Sortable(domElements.imageList, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        dragClass: 'sortable-drag',
        chosenClass: 'sortable-chosen',
        forceFallback: false, // Changed to false to use native HTML5 drag
        scroll: true,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        delay: 0, // Reduced delay
        delayOnTouchOnly: true,
        touchStartThreshold: 3,
        
        // Store initial index when drag starts
        onStart: function(evt) {
            draggedIndex = evt.oldIndex;
            // Clear any existing interval
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
            }
            
            // Set up auto-scroll with requestAnimationFrame for better performance
            function autoScroll() {
                const imageListRect = domElements.imageList.getBoundingClientRect();
                const draggedItemRect = evt.item.getBoundingClientRect();
                const scrollThreshold = 50;
                const maxScrollSpeed = 15;

                if (draggedItemRect.top < imageListRect.top + scrollThreshold) {
                    const intensity = 1 - ((draggedItemRect.top - imageListRect.top) / scrollThreshold);
                    domElements.imageList.scrollTop -= Math.min(maxScrollSpeed, intensity * maxScrollSpeed);
                } else if (draggedItemRect.bottom > imageListRect.bottom - scrollThreshold) {
                    const intensity = 1 - ((imageListRect.bottom - draggedItemRect.bottom) / scrollThreshold);
                    domElements.imageList.scrollTop += Math.min(maxScrollSpeed, intensity * maxScrollSpeed);
                }
                
                autoScrollInterval = requestAnimationFrame(autoScroll);
            }
            
            autoScrollInterval = requestAnimationFrame(autoScroll);
        },

        onEnd: function(evt) {
            // Cancel auto-scroll
            if (autoScrollInterval) {
                cancelAnimationFrame(autoScrollInterval);
            }

            // Only process if the position actually changed
            if (evt.oldIndex === evt.newIndex) return;

            // Batch DOM updates
            requestAnimationFrame(() => {
                // Update screenshots array efficiently
                const [movedItem] = constants.screenshots.splice(evt.oldIndex, 1);
                constants.screenshots.splice(evt.newIndex, 0, movedItem);
                
                // Update indices in a single pass
                const oldIndex = evt.oldIndex;
                const newIndex = evt.newIndex;
                const minIndex = Math.min(oldIndex, newIndex);
                const maxIndex = Math.max(oldIndex, newIndex);
                
                // Update box indices efficiently
                constants.boxes.forEach(box => {
                    if (box.screenshotIndex >= minIndex && box.screenshotIndex <= maxIndex) {
                        if (box.screenshotIndex === oldIndex) {
                            box.screenshotIndex = newIndex;
                        } else if (oldIndex < newIndex) {
                            box.screenshotIndex--;
                        } else {
                            box.screenshotIndex++;
                        }
                    }
                    
                    // Update linked indices
                    if (box.linkedTo !== null && box.linkedTo >= minIndex && box.linkedTo <= maxIndex) {
                        if (box.linkedTo === oldIndex) {
                            box.linkedTo = newIndex;
                        } else if (oldIndex < newIndex) {
                            box.linkedTo--;
                        } else {
                            box.linkedTo++;
                        }
                    }
                });

                // Update global box indices efficiently
                constants.globalBoxes.forEach(box => {
                    box.visibleOn = box.visibleOn.map(index => {
                        if (index >= minIndex && index <= maxIndex) {
                            if (index === oldIndex) return newIndex;
                            return oldIndex < newIndex ? index - 1 : index + 1;
                        }
                        return index;
                    });
                    box.linkedTo = box.linkedTo !== null ? oldIndexToNewIndex.get(box.linkedTo) : null; // <-- CORRECTED LINE
                });

                // Update current screenshot index if needed
                if (constants.currentScreenshotIndex >= minIndex && constants.currentScreenshotIndex <= maxIndex) {
                    if (constants.currentScreenshotIndex === oldIndex) {
                        constants.currentScreenshotIndex = newIndex;
                    } else if (oldIndex < newIndex) {
                        constants.currentScreenshotIndex--;
                    } else {
                        constants.currentScreenshotIndex++;
                    }
                }

                // Update UI
                core.updateImageList();
                core.displayScreenshot(constants.currentScreenshotIndex);
            });
        },

        // Simplified move handler
        onMove: function(evt, originalEvent) {
            if (evt.related.className === 'sortable-placeholder') return;
            return true;
        }
    });
});

    </script>
</body>
</html>